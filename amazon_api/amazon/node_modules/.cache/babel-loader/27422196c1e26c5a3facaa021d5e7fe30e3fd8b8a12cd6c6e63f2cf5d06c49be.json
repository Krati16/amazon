{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = void 0;\nvar debounce_1 = require(\"../debounce\");\nvar dirty_clean_1 = require(\"../dirty-clean\");\nvar dirty_props_1 = require(\"../dirty-props\");\nvar rangeUtil = require(\"../range-util\");\nvar util = require(\"../util\");\nfunction create(grid) {\n  var dirtyClean = dirty_clean_1.default(grid);\n  var container;\n  function getFirstClientRect() {\n    return container && container.getClientRects && container.getClientRects()[0];\n  }\n  function makeDimension(gridDimension) {\n    function getVirtualRowColUnsafe(coord) {\n      var numFixed = viewDimension._numFixed;\n      if (coord < numFixed) {\n        return coord;\n      }\n      return coord + gridDimension.cellScroll.position;\n    }\n    function getLengthBetweenViewCoords(startCoord, endCoord, inclusive) {\n      var toVirtual = viewDimension.toVirtual;\n      var lengthFn = gridDimension.virtualPixelCell.sizeOf;\n      var clampFn = viewDimension.clampCell;\n      var pos = 0;\n      var numFixed = viewDimension._numFixed;\n      var isInNonfixedArea = endCoord >= numFixed;\n      var isInFixedArea = startCoord < numFixed;\n      var exclusiveOffset = inclusive ? 0 : 1;\n      if (isInFixedArea) {\n        var fixedEndCoord = isInNonfixedArea ? numFixed - 1 : endCoord - exclusiveOffset;\n        pos += lengthFn(startCoord, fixedEndCoord);\n      }\n      if (isInNonfixedArea) {\n        var startOfNonFixed = isInFixedArea ? toVirtual(numFixed) : toVirtual(startCoord);\n        pos += lengthFn(startOfNonFixed, toVirtual(clampFn(endCoord)) - exclusiveOffset);\n      }\n      return pos;\n    }\n    function getRowOrColFromPosition(pos, returnVirtual) {\n      var viewMax = viewDimension.count;\n      var toVirtual = viewDimension.toVirtual;\n      var lengthFn = gridDimension.virtualPixelCell.sizeOf;\n      var fixedSize = gridDimension.virtualPixelCell.fixedSize();\n      var summedLength = grid.viewLayer.getBorderWidth() + (pos <= fixedSize ? 0 : gridDimension.pixelScroll.offset);\n      for (var i = 0; i < viewMax; i++) {\n        var virtual = toVirtual(i);\n        var length_1 = lengthFn(virtual);\n        var newSum = summedLength + length_1;\n        if (newSum >= pos) {\n          return returnVirtual ? virtual : i;\n        }\n        summedLength = newSum;\n      }\n      return NaN;\n    }\n    function calculateMaxLengths(totalLength) {\n      var lengthMethod = gridDimension.virtualPixelCell.sizeOf;\n      var numFixed = gridDimension.rowColModel.numFixed();\n      var windowLength = 0;\n      var maxSize = 0;\n      var fixedLength = 0;\n      var windowStartIndex = numFixed;\n      for (var fixed = 0; fixed < numFixed; fixed++) {\n        fixedLength += lengthMethod(fixed);\n      }\n      var maxLength = 0;\n      for (var index = numFixed; index < gridDimension.rowColModel.length(true); index++) {\n        var lengthOfIindex = lengthMethod(index);\n        if (lengthOfIindex > maxLength) {\n          maxLength = lengthOfIindex;\n        }\n      }\n      totalLength += maxLength;\n      for (var index = numFixed; index < gridDimension.rowColModel.length(true); index++) {\n        var lengthOfIindex = lengthMethod(index);\n        windowLength += lengthOfIindex;\n        while (windowLength + fixedLength > totalLength && windowStartIndex < index) {\n          windowLength -= lengthMethod(windowStartIndex);\n          windowStartIndex++;\n        }\n        var windowSize = index - windowStartIndex + 1;\n        if (windowSize > maxSize) {\n          maxSize = windowSize;\n        }\n      }\n      return Math.min(maxSize + numFixed + 1, gridDimension.rowColModel.length(true));\n    }\n    var viewDimension = dirty_props_1.default({\n      count: 0,\n      size: 0,\n      clientPx: {\n        get start() {\n          var clientRect = getFirstClientRect();\n          return clientRect && gridDimension.positionRange.getPosition(clientRect) || 0;\n        },\n        toGrid: function (clientPx) {\n          return clientPx - viewDimension.clientPx.start;\n        }\n      },\n      _numFixed: 0,\n      isInView: function (virtualCoord) {\n        var realRow = viewDimension.toReal(virtualCoord);\n        return !isNaN(realRow) && getLengthBetweenViewCoords(0, realRow, true) < viewDimension.totalSize();\n      },\n      toVirtual: function (viewCoord) {\n        var virtualRowCol = getVirtualRowColUnsafe(viewCoord);\n        return gridDimension.virtualPixelCell.clampCell(virtualRowCol);\n      },\n      toReal: function (virtualCoord) {\n        var numFixed = viewDimension._numFixed;\n        if (virtualCoord < numFixed) {\n          return virtualCoord;\n        }\n        var maxViewPortIndex = viewDimension.count - 1;\n        return util.clamp(virtualCoord - gridDimension.cellScroll.position, numFixed, maxViewPortIndex, true);\n      },\n      clampCell: function (coord) {\n        return util.clamp(coord, 0, viewDimension.count - 1);\n      },\n      clampPx: function (px) {\n        return util.clamp(px, 0, viewDimension.totalSize());\n      },\n      toPx: function (coord) {\n        return getLengthBetweenViewCoords(0, coord);\n      },\n      toVirtualFromPx: function (px) {\n        return getRowOrColFromPosition(px, true);\n      },\n      toViewFromPx: function (px) {\n        return getRowOrColFromPosition(px);\n      },\n      sizeOf: function (viewCoord) {\n        return gridDimension.virtualPixelCell.sizeOf(viewDimension.toVirtual(viewDimension.clampCell(viewCoord)));\n      },\n      totalSize: function () {\n        return viewDimension.size;\n      },\n      intersect: function (intersection, range) {\n        var numFixed = viewDimension._numFixed;\n        var fixedRange = [0, numFixed];\n        var virtualRange = [gridDimension.positionRange.getPosition(range), gridDimension.positionRange.getSize(range)];\n        var fixedIntersection = rangeUtil.intersect(fixedRange, virtualRange);\n        var scrollRange = [numFixed, viewDimension.count - numFixed];\n        virtualRange[0] -= gridDimension.cellScroll.position;\n        var scrollIntersection = rangeUtil.intersect(scrollRange, virtualRange);\n        var resultRange = rangeUtil.union(fixedIntersection, scrollIntersection);\n        if (!resultRange) {\n          return null;\n        }\n        gridDimension.positionRange.setPosition(intersection, resultRange[0]);\n        gridDimension.positionRange.setSize(intersection, resultRange[1]);\n        return intersection;\n      },\n      updateSize: function (newSize) {\n        var oldSize = viewDimension.size;\n        viewDimension.size = newSize;\n        viewDimension.count = calculateMaxLengths(newSize);\n        return oldSize !== newSize;\n      },\n      _getLengthBetweenCoords: getLengthBetweenViewCoords\n    }, ['count', 'size'], [dirtyClean]);\n    return viewDimension;\n  }\n  var dimensions = {\n    rowInfo: makeDimension(grid.rows),\n    colInfo: makeDimension(grid.cols)\n  };\n  var viewPort = {\n    _onResize: debounce_1.default(function () {\n      viewPort._resize();\n    }, 200),\n    shortDebouncedResize: debounce_1.default(function () {\n      viewPort._resize();\n    }, 1),\n    isDirty: dirtyClean.isDirty,\n    sizeToContainer: function (elem) {\n      container = elem;\n      var isHeightChange = viewPort.rowInfo.updateSize(elem.offsetHeight);\n      var isWidthChange = viewPort.colInfo.updateSize(elem.offsetWidth);\n      var event = {\n        type: 'grid-viewport-change',\n        isWidthChange: isWidthChange,\n        isHeightChange: isHeightChange,\n        isSizeChange: isWidthChange || isHeightChange\n      };\n      grid.eventLoop.fire(event);\n    },\n    _resize: function () {\n      if (container) {\n        viewPort.sizeToContainer(container);\n      }\n    },\n    toPx: function (realCellRange) {\n      return {\n        top: viewPort.getRowTop(realCellRange.top),\n        left: viewPort.getColLeft(realCellRange.left),\n        height: viewPort.rowInfo._getLengthBetweenCoords(realCellRange.top, realCellRange.top + realCellRange.height - 1, true),\n        width: viewPort.colInfo._getLengthBetweenCoords(realCellRange.left, realCellRange.left + realCellRange.width - 1, true)\n      };\n    },\n    intersect: function (range) {\n      var intersection = viewPort.rowInfo.intersect({}, range);\n      if (!intersection) {\n        return null;\n      }\n      return viewPort.colInfo.intersect(intersection, range);\n    },\n    iterateCells: function (cellFn, rowFn, maxRow, maxCol) {\n      if (maxRow === void 0) {\n        maxRow = Infinity;\n      }\n      if (maxCol === void 0) {\n        maxCol = Infinity;\n      }\n      for (var r = 0; r < Math.min(viewPort.rows, maxRow); r++) {\n        if (rowFn) {\n          rowFn(r);\n        }\n        if (cellFn) {\n          for (var c = 0; c < Math.min(viewPort.cols, maxCol); c++) {\n            cellFn(r, c);\n          }\n        }\n      }\n    },\n    get rows() {\n      return dimensions.rowInfo.count;\n    },\n    set rows(r) {\n      dimensions.rowInfo.count = r;\n    },\n    get cols() {\n      return dimensions.colInfo.count;\n    },\n    set cols(c) {\n      dimensions.colInfo.count = c;\n    },\n    get height() {\n      return dimensions.rowInfo.size;\n    },\n    set height(s) {\n      dimensions.rowInfo.size = s;\n    },\n    get width() {\n      return dimensions.colInfo.size;\n    },\n    set width(s) {\n      dimensions.colInfo.size = s;\n    },\n    get top() {\n      return dimensions.rowInfo.clientPx.start;\n    },\n    get left() {\n      return dimensions.colInfo.clientPx.start;\n    },\n    toGridY: dimensions.rowInfo.clientPx.toGrid,\n    toGridX: dimensions.colInfo.clientPx.toGrid,\n    toVirtualRow: dimensions.rowInfo.toVirtual,\n    toVirtualCol: dimensions.colInfo.toVirtual,\n    rowIsInView: dimensions.rowInfo.isInView,\n    colIsInView: dimensions.colInfo.isInView,\n    toRealRow: dimensions.rowInfo.toReal,\n    toRealCol: dimensions.colInfo.toReal,\n    clampRow: dimensions.rowInfo.clampCell,\n    clampCol: dimensions.colInfo.clampCell,\n    clampY: dimensions.rowInfo.clampPx,\n    clampX: dimensions.colInfo.clampPx,\n    getRowTop: dimensions.rowInfo.toPx,\n    getColLeft: dimensions.colInfo.toPx,\n    getVirtualRowByTop: dimensions.rowInfo.toVirtualFromPx,\n    getVirtualColByLeft: dimensions.colInfo.toVirtualFromPx,\n    getRowByTop: dimensions.rowInfo.toViewFromPx,\n    getColByLeft: dimensions.colInfo.toViewFromPx,\n    getRowHeight: dimensions.rowInfo.sizeOf,\n    getColWidth: dimensions.colInfo.sizeOf,\n    rowInfo: dimensions.rowInfo,\n    colInfo: dimensions.colInfo\n  };\n  grid.eventLoop.bind('grid-destroy', function () {\n    viewPort._onResize.cancel();\n    viewPort.shortDebouncedResize.cancel();\n  });\n  grid.eventLoop.bind(window, 'resize', function () {\n    viewPort._onResize();\n  });\n  grid.eventLoop.bind('grid-row-change', function () {\n    viewPort.rowInfo._numFixed = grid.rowModel.numFixed();\n    viewPort.shortDebouncedResize();\n  });\n  grid.eventLoop.bind('grid-col-change', function () {\n    viewPort.colInfo._numFixed = grid.colModel.numFixed();\n    viewPort.shortDebouncedResize();\n  });\n  return viewPort;\n}\nexports.create = create;\nexports.default = create;","map":{"version":3,"names":["debounce_1","require","dirty_clean_1","dirty_props_1","rangeUtil","util","create","grid","dirtyClean","default","container","getFirstClientRect","getClientRects","makeDimension","gridDimension","getVirtualRowColUnsafe","coord","numFixed","viewDimension","_numFixed","cellScroll","position","getLengthBetweenViewCoords","startCoord","endCoord","inclusive","toVirtual","lengthFn","virtualPixelCell","sizeOf","clampFn","clampCell","pos","isInNonfixedArea","isInFixedArea","exclusiveOffset","fixedEndCoord","startOfNonFixed","getRowOrColFromPosition","returnVirtual","viewMax","count","fixedSize","summedLength","viewLayer","getBorderWidth","pixelScroll","offset","i","virtual","length_1","newSum","NaN","calculateMaxLengths","totalLength","lengthMethod","rowColModel","windowLength","maxSize","fixedLength","windowStartIndex","fixed","maxLength","index","length","lengthOfIindex","windowSize","Math","min","size","clientPx","start","clientRect","positionRange","getPosition","toGrid","isInView","virtualCoord","realRow","toReal","isNaN","totalSize","viewCoord","virtualRowCol","maxViewPortIndex","clamp","clampPx","px","toPx","toVirtualFromPx","toViewFromPx","intersect","intersection","range","fixedRange","virtualRange","getSize","fixedIntersection","scrollRange","scrollIntersection","resultRange","union","setPosition","setSize","updateSize","newSize","oldSize","_getLengthBetweenCoords","dimensions","rowInfo","rows","colInfo","cols","viewPort","_onResize","_resize","shortDebouncedResize","isDirty","sizeToContainer","elem","isHeightChange","offsetHeight","isWidthChange","offsetWidth","event","type","isSizeChange","eventLoop","fire","realCellRange","top","getRowTop","left","getColLeft","height","width","iterateCells","cellFn","rowFn","maxRow","maxCol","Infinity","r","c","s","toGridY","toGridX","toVirtualRow","toVirtualCol","rowIsInView","colIsInView","toRealRow","toRealCol","clampRow","clampCol","clampY","clampX","getVirtualRowByTop","getVirtualColByLeft","getRowByTop","getColByLeft","getRowHeight","getColWidth","bind","cancel","window","rowModel","colModel","exports"],"sources":["C:\\amazon\\amazon\\node_modules\\grid\\src\\modules\\view-port\\index.ts"],"sourcesContent":["import { Grid, IGridDimension } from '../core';\nimport debounce, { IDebounceFunction } from '../debounce';\nimport makeDirtyClean from '../dirty-clean';\nimport addDirtyProps from '../dirty-props';\nimport {\n    RawPositionRange,\n} from '../position-range';\nimport * as rangeUtil from '../range-util';\nimport * as util from '../util';\n\nexport interface IViewPort {\n    rowInfo: IViewPortDimensionInfo;\n    colInfo: IViewPortDimensionInfo;\n    _onResize: IDebounceFunction;\n    shortDebouncedResize: IDebounceFunction;\n\n    // BEGIN: methods / properties proxied to a dimension impl\n    rows: IViewPortDimensionInfo['count'];\n    cols: IViewPortDimensionInfo['count'];\n    top: IViewPortDimensionInfo['clientPx']['start'];\n    left: IViewPortDimensionInfo['clientPx']['start'];\n    width: IViewPortDimensionInfo['size'];\n    height: IViewPortDimensionInfo['size'];\n    toGridX: IViewPortDimensionInfo['clientPx']['toGrid'];\n    toGridY: IViewPortDimensionInfo['clientPx']['toGrid'];\n    toVirtualRow: IViewPortDimensionInfo['toVirtual'];\n    toVirtualCol: IViewPortDimensionInfo['toVirtual'];\n    rowIsInView: IViewPortDimensionInfo['isInView'];\n    colIsInView: IViewPortDimensionInfo['isInView'];\n    toRealRow: IViewPortDimensionInfo['toReal'];\n    toRealCol: IViewPortDimensionInfo['toReal'];\n    clampRow: IViewPortDimensionInfo['clampCell'];\n    clampCol: IViewPortDimensionInfo['clampCell'];\n    clampY: IViewPortDimensionInfo['clampPx'];\n    clampX: IViewPortDimensionInfo['clampPx'];\n    getRowTop: IViewPortDimensionInfo['toPx'];\n    getColLeft: IViewPortDimensionInfo['toPx'];\n    getVirtualRowByTop: IViewPortDimensionInfo['toVirtualFromPx'];\n    getVirtualColByLeft: IViewPortDimensionInfo['toVirtualFromPx'];\n    getRowByTop: IViewPortDimensionInfo['toViewFromPx'];\n    getColByLeft: IViewPortDimensionInfo['toViewFromPx'];\n    getRowHeight: IViewPortDimensionInfo['sizeOf'];\n    getColWidth: IViewPortDimensionInfo['sizeOf'];\n    // END: methods / properties proxied to a dimension impl\n\n    isDirty(): boolean;\n    sizeToContainer(elem: HTMLElement): void;\n    _resize(): void;\n    toPx(realCellRange: RawPositionRange): RawPositionRange;\n    intersect(range: RawPositionRange): RawPositionRange | null;\n    iterateCells(\n        cellFn: (r: number, c: number) => void,\n        rowFn?: (r: number) => void,\n        optionalMaxRow?: number,\n        optionalMaxCol?: number\n    ): void;\n}\n\nexport interface IViewPortDimensionInfo {\n    count: number;\n    size: number;\n    clientPx: {\n        start: number;\n        toGrid(clientPx: number): number;\n    };\n    _numFixed: number;\n    _getLengthBetweenCoords(s: number, e: number, inclusive?: boolean): number;\n    isInView(virtualCoord: number): boolean;\n    toVirtual(viewCoord: number): number;\n    toReal(virtualCoord: number): number;\n    clampCell(coord: number): number;\n    clampPx(px: number): number;\n    toPx(coord: number): number;\n    toVirtualFromPx(px: number): number;\n    toViewFromPx(px: number): number;\n    sizeOf(viewCoord: number): number;\n    totalSize(): number;\n    updateSize(newSize: number): boolean;\n    intersect(intersection: RawPositionRange, range: RawPositionRange): RawPositionRange | null;\n}\n\nexport function create(grid: Grid) {\n    const dirtyClean = makeDirtyClean(grid);\n    let container: HTMLElement | undefined;\n\n    // these probably trigger reflow so we may need to think about caching the value and updating it at on draws or something\n    function getFirstClientRect() {\n        return container && container.getClientRects && container.getClientRects()[0];\n    }\n\n    function makeDimension(\n        gridDimension: IGridDimension\n    ) {\n        function getVirtualRowColUnsafe(coord: number) {\n            // could cache this on changes i.e. row-change or col-change events\n            const numFixed = viewDimension._numFixed;\n            if (coord < numFixed) {\n                return coord;\n            }\n            return coord + gridDimension.cellScroll.position;\n        }\n\n        function getLengthBetweenViewCoords(\n            startCoord: number,\n            endCoord: number,\n            inclusive?: boolean\n        ) {\n            const toVirtual = viewDimension.toVirtual;\n            const lengthFn = gridDimension.virtualPixelCell.sizeOf;\n            const clampFn = viewDimension.clampCell;\n            let pos = 0;\n            const numFixed = viewDimension._numFixed;\n            const isInNonfixedArea = endCoord >= numFixed;\n            const isInFixedArea = startCoord < numFixed;\n            const exclusiveOffset = (inclusive ? 0 : 1);\n            if (isInFixedArea) {\n                const fixedEndCoord = (isInNonfixedArea ? numFixed - 1 : endCoord - exclusiveOffset);\n                pos += lengthFn(startCoord, fixedEndCoord);\n            }\n            if (isInNonfixedArea) {\n                const startOfNonFixed = isInFixedArea ? toVirtual(numFixed) : toVirtual(startCoord);\n                pos += lengthFn(startOfNonFixed, toVirtual(clampFn(endCoord)) - exclusiveOffset);\n            }\n            return pos;\n        }\n\n        function getRowOrColFromPosition(pos: number, returnVirtual?: boolean) {\n            // we could do this slighly faster with binary search to get log(n) instead of n,\n            // but will only do it if we actually need to optimize this\n            const viewMax = viewDimension.count;\n            const toVirtual = viewDimension.toVirtual;\n            const lengthFn = gridDimension.virtualPixelCell.sizeOf;\n            const fixedSize = gridDimension.virtualPixelCell.fixedSize();\n            let summedLength = grid.viewLayer.getBorderWidth() + (pos <= fixedSize ? 0 : gridDimension.pixelScroll.offset);\n            for (let i = 0; i < viewMax; i++) {\n                const virtual = toVirtual(i);\n                const length = lengthFn(virtual);\n                const newSum = summedLength + length;\n                if (newSum >= pos) {\n                    return returnVirtual ? virtual : i;\n                }\n                summedLength = newSum;\n            }\n            return NaN;\n        }\n\n        function calculateMaxLengths(totalLength: number) {\n            const lengthMethod = gridDimension.virtualPixelCell.sizeOf;\n            const numFixed = gridDimension.rowColModel.numFixed();\n            let windowLength = 0;\n            let maxSize = 0;\n            let fixedLength = 0;\n            let windowStartIndex = numFixed;\n\n            for (let fixed = 0; fixed < numFixed; fixed++) {\n                fixedLength += lengthMethod(fixed);\n            }\n\n            let maxLength = 0;\n            for (let index = numFixed; index < gridDimension.rowColModel.length(true); index++) {\n                const lengthOfIindex = lengthMethod(index);\n                if (lengthOfIindex > maxLength) {\n                    maxLength = lengthOfIindex;\n                }\n            }\n            totalLength += maxLength;\n\n            // it might be safer to actually sum the lengths in the virtualPixelCellModel but for now here is ok\n            for (let index = numFixed; index < gridDimension.rowColModel.length(true); index++) {\n                const lengthOfIindex = lengthMethod(index);\n                windowLength += lengthOfIindex;\n                while (windowLength + fixedLength > totalLength && windowStartIndex < index) {\n                    windowLength -= lengthMethod(windowStartIndex);\n                    windowStartIndex++;\n                }\n                const windowSize = index - windowStartIndex + 1; // add the one because we want the last index that didn't fit\n                if (windowSize > maxSize) {\n                    maxSize = windowSize;\n                }\n\n            }\n            return Math.min(maxSize + numFixed + 1, gridDimension.rowColModel.length(true));\n        }\n\n        const viewDimension: IViewPortDimensionInfo = addDirtyProps({\n            count: 0,\n            size: 0,\n            clientPx: {\n                get start() {\n                    const clientRect = getFirstClientRect();\n                    return clientRect && gridDimension.positionRange.getPosition(clientRect) || 0;\n                },\n                toGrid(clientPx: number) {\n                    return clientPx - viewDimension.clientPx.start;\n                }\n            },\n            _numFixed: 0,\n            isInView(virtualCoord: number) {\n                const realRow = viewDimension.toReal(virtualCoord);\n                return !isNaN(realRow) &&\n                    getLengthBetweenViewCoords(0, realRow, true) < viewDimension.totalSize();\n            },\n            toVirtual(viewCoord: number) {\n                const virtualRowCol = getVirtualRowColUnsafe(viewCoord);\n                return gridDimension.virtualPixelCell.clampCell(virtualRowCol);\n            },\n            toReal(virtualCoord: number) {\n                const numFixed = viewDimension._numFixed;\n                if (virtualCoord < numFixed) {\n                    return virtualCoord;\n                }\n                const maxViewPortIndex = viewDimension.count - 1;\n                return util.clamp(virtualCoord - gridDimension.cellScroll.position, numFixed, maxViewPortIndex, true);\n            },\n            clampCell(coord: number) {\n                return util.clamp(coord, 0, viewDimension.count - 1);\n            },\n            clampPx(px: number) {\n                return util.clamp(px, 0, viewDimension.totalSize());\n            },\n            toPx(coord: number) {\n                return getLengthBetweenViewCoords(0, coord);\n            },\n            toVirtualFromPx(px: number) {\n                return getRowOrColFromPosition(px, true);\n            },\n            toViewFromPx(px: number) {\n                return getRowOrColFromPosition(px);\n            },\n            sizeOf(viewCoord: number) {\n                return gridDimension.virtualPixelCell.sizeOf(viewDimension.toVirtual(viewDimension.clampCell(viewCoord)));\n            },\n            totalSize() {\n                return viewDimension.size;\n            },\n            // TODO: based on looking at the code i think range can sometimes be Partial, def worth checking for npes\n            intersect(intersection: RawPositionRange, range: RawPositionRange) {\n                const numFixed = viewDimension._numFixed;\n                const fixedRange = [0, numFixed];\n\n                const virtualRange = [gridDimension.positionRange.getPosition(range), gridDimension.positionRange.getSize(range)];\n                const fixedIntersection = rangeUtil.intersect(fixedRange, virtualRange);\n                const scrollRange = [numFixed, viewDimension.count - numFixed];\n                virtualRange[0] -= gridDimension.cellScroll.position;\n                const scrollIntersection = rangeUtil.intersect(scrollRange, virtualRange);\n                const resultRange = rangeUtil.union(fixedIntersection, scrollIntersection);\n                if (!resultRange) {\n                    return null;\n                }\n\n                gridDimension.positionRange.setPosition(intersection, resultRange[0]);\n                gridDimension.positionRange.setSize(intersection, resultRange[1]);\n                return intersection;\n            },\n            updateSize(newSize: number) {\n                const oldSize = viewDimension.size;\n                viewDimension.size = newSize;\n                viewDimension.count = calculateMaxLengths(newSize);\n                return oldSize !== newSize;\n            },\n            _getLengthBetweenCoords: getLengthBetweenViewCoords\n        }, ['count', 'size'], [dirtyClean]);\n        return viewDimension;\n    }\n\n    const dimensions = {\n        rowInfo: makeDimension(grid.rows),\n        colInfo: makeDimension(grid.cols)\n    };\n\n    const viewPort: IViewPort = {\n        _onResize: debounce(() => {\n            viewPort._resize();\n        }, 200),\n        shortDebouncedResize: debounce(() => {\n            viewPort._resize();\n        }, 1),\n        isDirty: dirtyClean.isDirty,\n\n        sizeToContainer(elem: HTMLElement) {\n            container = elem;\n            const isHeightChange = viewPort.rowInfo.updateSize(elem.offsetHeight);\n            const isWidthChange = viewPort.colInfo.updateSize(elem.offsetWidth);\n            const event = {\n                type: 'grid-viewport-change',\n                isWidthChange,\n                isHeightChange,\n                isSizeChange: isWidthChange || isHeightChange,\n            };\n            grid.eventLoop.fire(event);\n        },\n        _resize() {\n            if (container) {\n                viewPort.sizeToContainer(container);\n            }\n        },\n        toPx(realCellRange: RawPositionRange) {\n            return {\n                top: viewPort.getRowTop(realCellRange.top),\n                left: viewPort.getColLeft(realCellRange.left),\n                height: viewPort.rowInfo._getLengthBetweenCoords(realCellRange.top, realCellRange.top + realCellRange.height - 1, true),\n                width: viewPort.colInfo._getLengthBetweenCoords(realCellRange.left, realCellRange.left + realCellRange.width - 1, true)\n            };\n        },\n        intersect(range: RawPositionRange) {\n            // assume virtual cells for now\n            const intersection = viewPort.rowInfo.intersect({} as any, range);\n            if (!intersection) {\n                return null;\n            }\n            return viewPort.colInfo.intersect(intersection, range);\n        },\n        iterateCells(\n            cellFn: (r: number, c: number) => void,\n            rowFn?: (r: number) => void,\n            maxRow: number = Infinity,\n            maxCol: number = Infinity\n        ) {\n            for (let r = 0; r < Math.min(viewPort.rows, maxRow); r++) {\n                if (rowFn) {\n                    rowFn(r);\n                }\n                if (cellFn) {\n                    for (let c = 0; c < Math.min(viewPort.cols, maxCol); c++) {\n                        cellFn(r, c);\n\n                    }\n                }\n            }\n        },\n        // BEGIN: proxy to dimension\n        get rows() {\n            return dimensions.rowInfo.count;\n        },\n        set rows(r: number) {\n            dimensions.rowInfo.count = r;\n        },\n        get cols() {\n            return dimensions.colInfo.count;\n        },\n        set cols(c: number) {\n            dimensions.colInfo.count = c;\n        },\n        get height() {\n            return dimensions.rowInfo.size;\n        },\n        set height(s: number) {\n            dimensions.rowInfo.size = s;\n        },\n        get width() {\n            return dimensions.colInfo.size;\n        },\n        set width(s: number) {\n            dimensions.colInfo.size = s;\n        },\n        get top() {\n            return dimensions.rowInfo.clientPx.start;\n        },\n        get left() {\n            return dimensions.colInfo.clientPx.start;\n        },\n        toGridY: dimensions.rowInfo.clientPx.toGrid,\n        toGridX: dimensions.colInfo.clientPx.toGrid,\n        toVirtualRow: dimensions.rowInfo.toVirtual,\n        toVirtualCol: dimensions.colInfo.toVirtual,\n        rowIsInView: dimensions.rowInfo.isInView,\n        colIsInView: dimensions.colInfo.isInView,\n        toRealRow: dimensions.rowInfo.toReal,\n        toRealCol: dimensions.colInfo.toReal,\n        clampRow: dimensions.rowInfo.clampCell,\n        clampCol: dimensions.colInfo.clampCell,\n        clampY: dimensions.rowInfo.clampPx,\n        clampX: dimensions.colInfo.clampPx,\n        getRowTop: dimensions.rowInfo.toPx,\n        getColLeft: dimensions.colInfo.toPx,\n        getVirtualRowByTop: dimensions.rowInfo.toVirtualFromPx,\n        getVirtualColByLeft: dimensions.colInfo.toVirtualFromPx,\n        getRowByTop: dimensions.rowInfo.toViewFromPx,\n        getColByLeft: dimensions.colInfo.toViewFromPx,\n        getRowHeight: dimensions.rowInfo.sizeOf,\n        getColWidth: dimensions.colInfo.sizeOf,\n        // END: proxy to dimension\n        rowInfo: dimensions.rowInfo,\n        colInfo: dimensions.colInfo,\n    };\n\n    grid.eventLoop.bind('grid-destroy', () => {\n        viewPort._onResize.cancel();\n        viewPort.shortDebouncedResize.cancel();\n    });\n\n    grid.eventLoop.bind(window, 'resize', () => {\n        // we don't bind the handler directly so that tests can mock it out\n        viewPort._onResize();\n    });\n\n    grid.eventLoop.bind('grid-row-change', () => {\n        viewPort.rowInfo._numFixed = grid.rowModel.numFixed();\n        viewPort.shortDebouncedResize();\n    });\n\n    grid.eventLoop.bind('grid-col-change', () => {\n        viewPort.colInfo._numFixed = grid.colModel.numFixed();\n        viewPort.shortDebouncedResize();\n    });\n\n    return viewPort;\n}\n\nexport default create;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}