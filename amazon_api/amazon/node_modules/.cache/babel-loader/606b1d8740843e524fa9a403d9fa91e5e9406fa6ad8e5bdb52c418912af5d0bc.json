{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = void 0;\nvar ctrl_or_cmd_1 = require(\"../ctrl-or-cmd\");\nvar rangeUtil = require(\"../range-util\");\nvar util = require(\"../util\");\nvar key = require('key');\nvar arrow = key.code.arrow;\nfunction create(grid) {\n  var mainSelection = createAndAddSelectionDecorator(0, 0, -1, -1);\n  var model = {\n    focus: {\n      row: 0,\n      col: 0\n    },\n    get selection() {\n      if (mainSelection.height === -1) {\n        return {\n          top: model.focus.row,\n          left: model.focus.col,\n          height: 1,\n          width: 1\n        };\n      }\n      return mainSelection;\n    },\n    otherSelections: [],\n    checkboxModeFor: {},\n    _selectionDecorator: mainSelection,\n    focusDecorator: grid.decorators.create(0, 0, 1, 1),\n    _rowSelectionClasses: [],\n    _colSelectionClasses: [],\n    getAllSelections: function () {\n      var selections = [];\n      if (model.selection) {\n        selections.push(model.selection);\n      }\n      return selections.concat(model.otherSelections);\n    },\n    setFocus: function (inputRow, inputCol, dontClearSelection, dontSetSelection) {\n      inputRow = inputRow && grid.data.row.clamp(inputRow);\n      var row = typeof inputRow !== 'number' || isNaN(inputRow) ? model.focus.row : inputRow;\n      inputCol = inputCol && grid.data.col.clamp(inputCol);\n      var col = typeof inputCol !== 'number' || isNaN(inputCol) ? model.focus.row : inputCol;\n      var changed = row !== model.focus.row || col !== model.focus.col;\n      model.focus.row = row;\n      model.focus.col = col;\n      focusClass.top = row;\n      focusClass.left = col;\n      model.focusDecorator.top = row;\n      model.focusDecorator.left = col;\n      grid.cellScrollModel.scrollIntoView(row, col);\n      if (!dontClearSelection) {\n        clearOtherSelections();\n      }\n      if (!dontSetSelection) {\n        setSelectionToFocus();\n      }\n      if (changed) {\n        grid.eventLoop.fire('grid-focus-change');\n      }\n    },\n    _navFrom: navFrom,\n    handleTabEvent: function (e) {\n      var newCol = model.focus.col;\n      var newRow = model.focus.row;\n      if (!e || !e.shiftKey) {\n        if (newCol === grid.data.col.count() - 1) {\n          newRow = grid.data.down(newRow);\n          newCol = 0;\n        } else {\n          newCol = grid.data.right(newCol);\n        }\n      } else {\n        if (newCol === 0) {\n          newRow = grid.data.up(newRow);\n          newCol = grid.data.col.count() - 1;\n        } else {\n          newCol = grid.data.left(newCol);\n        }\n      }\n      model.setFocus(newRow, newCol);\n      e.preventDefault();\n    },\n    setSelection: function (newSelection) {\n      var height = newSelection.height;\n      var width = newSelection.width;\n      if (selectionIsFocus(newSelection)) {\n        height = -1;\n        width = -1;\n      }\n      mainSelection.top = newSelection.top;\n      mainSelection.left = newSelection.left;\n      mainSelection.height = height;\n      mainSelection.width = width;\n      syncSelectionToHeaders();\n    },\n    getAllSelectedRanges: function () {\n      var selectionRange = grid.navigationModel.selection;\n      if (selectionRange.top === -1) {\n        selectionRange = {\n          top: grid.navigationModel.focus.row,\n          left: grid.navigationModel.focus.col,\n          width: 1,\n          height: 1\n        };\n      }\n      return [selectionRange].concat(model.otherSelections);\n    },\n    clearSelection: function () {\n      clearOtherSelections();\n      setSelectionToFocus();\n    }\n  };\n  var focusClass = grid.cellClasses.create(0, 0, 'focus');\n  grid.cellClasses.add(focusClass);\n  model.focusDecorator.postRender = function (div) {\n    div.setAttribute('class', 'grid-focus-decorator');\n    return div;\n  };\n  grid.decorators.add(model.focusDecorator);\n  function seekNextEdge(newIndex, startedDefined, isForwardEdge, isBackwardEdge, goForward) {\n    var isEdgeToSeek = (isForwardEdge(newIndex) || !startedDefined) && isBackwardEdge || isForwardEdge;\n    while (newIndex !== undefined && goForward(newIndex) !== undefined && !isEdgeToSeek(newIndex = goForward(newIndex))) {}\n    return newIndex;\n  }\n  function navFrom(row, col, e) {\n    var newRow = row;\n    var newCol = col;\n    var isSeek = ctrl_or_cmd_1.default(e);\n    if (isSeek) {\n      var cellHasValue_1 = function (r, c) {\n        if (r === undefined || c === undefined) {\n          return false;\n        }\n        return !!grid.dataModel.get(r, c).formatted;\n      };\n      var isLeftwardEdge = function (c) {\n        return cellHasValue_1(newRow, c) && !cellHasValue_1(newRow, grid.data.left(c));\n      };\n      var isRightwardEdge = function (c) {\n        return cellHasValue_1(newRow, c) && !cellHasValue_1(newRow, grid.data.right(c));\n      };\n      var isUpwardEdge = function (r) {\n        return cellHasValue_1(r, newCol) && !cellHasValue_1(grid.data.up(r), newCol);\n      };\n      var isDownwardEdge = function (r) {\n        return cellHasValue_1(r, newCol) && !cellHasValue_1(grid.data.down(r), newCol);\n      };\n      var startedDefined = cellHasValue_1(newRow, newCol);\n      switch (e.which) {\n        case arrow.down.code:\n          newRow = seekNextEdge(newRow, startedDefined, isDownwardEdge, isUpwardEdge, grid.data.down);\n          break;\n        case arrow.up.code:\n          newRow = seekNextEdge(newRow, startedDefined, isUpwardEdge, isDownwardEdge, grid.data.up);\n          break;\n        case arrow.right.code:\n          newCol = seekNextEdge(newCol, startedDefined, isRightwardEdge, isLeftwardEdge, grid.data.right);\n          break;\n        case arrow.left.code:\n          newCol = seekNextEdge(newCol, startedDefined, isLeftwardEdge, isRightwardEdge, grid.data.left);\n          break;\n      }\n    } else {\n      switch (e.which) {\n        case arrow.down.code:\n          newRow = grid.data.down(newRow);\n          break;\n        case arrow.up.code:\n          newRow = grid.data.up(newRow);\n          break;\n        case arrow.right.code:\n          newCol = grid.data.right(newCol);\n          break;\n        case arrow.left.code:\n          newCol = grid.data.left(newCol);\n          break;\n      }\n    }\n    if (newRow === undefined) {\n      newRow = row;\n    }\n    if (newCol === undefined) {\n      newCol = col;\n    }\n    return {\n      row: newRow,\n      col: newCol\n    };\n  }\n  grid.eventLoop.bind('keydown', function (e) {\n    if (!grid.focused) {\n      return;\n    }\n    if (key.is(key.code.special.tab, e.which)) {\n      model.handleTabEvent(e);\n      return;\n    }\n    if (!key.is(arrow, e.which)) {\n      return;\n    }\n    if (!e.shiftKey) {\n      var newFocus = navFrom(model.focus.row, model.focus.col, e);\n      model.setFocus(newFocus.row, newFocus.col, true);\n    } else {\n      var newSelection = void 0;\n      if (model.selection.top === -1) {\n        newSelection = {\n          top: model.focus.row,\n          left: model.focus.col,\n          height: 1,\n          width: 1\n        };\n      } else {\n        newSelection = {\n          top: model.selection.top,\n          left: model.selection.left,\n          height: model.selection.height,\n          width: model.selection.width\n        };\n      }\n      var navFromRow = model.focus.row === newSelection.top ? newSelection.top + newSelection.height - 1 : newSelection.top;\n      var navFromCol = model.focus.col === newSelection.left ? newSelection.left + newSelection.width - 1 : newSelection.left;\n      var newRowCol = navFrom(navFromRow, navFromCol, e);\n      setSelectionFromPoints(model.focus.row, model.focus.col, newRowCol.row, newRowCol.col);\n      grid.cellScrollModel.scrollIntoView(newRowCol.row, newRowCol.col);\n    }\n  });\n  function isNavableMouseEvent(e) {\n    var target = e.target;\n    return !target || grid.eventIsOnCells(e) && e.button !== 2;\n  }\n  function isCheckboxModeForRowCol(row, col) {\n    return model.checkboxModeFor.rows && col < 0 || row < 0 && colSelectable(col) && model.checkboxModeFor.cols;\n  }\n  grid.eventLoop.bind('mousedown', function (e) {\n    if (!isNavableMouseEvent(e)) {\n      return;\n    }\n    var row = e.row;\n    var col = e.col;\n    var isCheckboxMode = isCheckboxModeForRowCol(row, col);\n    var ctrlOrCmdPressed = isCheckboxMode || ctrl_or_cmd_1.default(e);\n    if (e.shiftKey) {\n      var fromRow = model.focus.row;\n      var fromCol = model.focus.col;\n      var toRow = row;\n      var toCol = col;\n      var wasSelected = void 0;\n      if (toRow < 0) {\n        var colDescriptor = grid.data.col.get(toCol);\n        if (colDescriptor.selectable !== false) {\n          wasSelected = colDescriptor.selected;\n          fromRow = 0;\n          toRow = Infinity;\n        }\n      }\n      if (toCol < 0) {\n        wasSelected = grid.data.row.get(toRow).selected;\n        fromCol = 0;\n        toCol = Infinity;\n      }\n      selectFromFocusToCell(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed, wasSelected);\n    } else {\n      var focusRow = row;\n      if (focusRow < 0) {\n        focusRow = grid.view.row.toData(grid.rowModel.numHeaders());\n      }\n      var focusCol = col;\n      if (focusCol < 0) {\n        focusCol = grid.view.col.toData(grid.colModel.numHeaders());\n      }\n      var headerSelectionRange_1 = createHeaderSelectionRange(row, col);\n      if (headerSelectionRange_1) {\n        var prevSelections = findFullRowOrColSelections(headerSelectionRange_1);\n        if (prevSelections.length && isCheckboxMode) {\n          var selectAll = headerSelectionRange_1.width === Infinity && headerSelectionRange_1.height === Infinity && !(grid.rowModel.allSelected() || grid.colModel.allSelected());\n          prevSelections.forEach(function (prevSelection) {\n            removeFullRowOrColFromSelection(prevSelection, headerSelectionRange_1);\n          });\n          if (selectAll) {\n            model.setSelection(headerSelectionRange_1);\n          }\n          model.setFocus(focusRow, focusCol, true, true);\n        } else {\n          if (ctrlOrCmdPressed && !selectionIsFocus(model.selection)) {\n            addSelection(model.selection);\n          } else {\n            clearOtherSelections();\n          }\n          model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);\n          model.setSelection(headerSelectionRange_1);\n        }\n      } else {\n        if (ctrlOrCmdPressed) {\n          addSelection(model.selection);\n        }\n        model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);\n      }\n    }\n  });\n  function selectFromFocusToCell(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed, wasSelected) {\n    var isCheckboxMode = fromRow === 0 && toRow === Infinity && model.checkboxModeFor.cols || fromCol === 0 && toCol === Infinity && model.checkboxModeFor.rows;\n    if (!wasSelected || !isCheckboxMode) {\n      setSelectionFromPoints(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed);\n    } else {\n      var range_1 = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);\n      var prevSelections = findFullRowOrColSelections(range_1);\n      if (prevSelections.length) {\n        prevSelections.forEach(function (prevSelection) {\n          removeFullRowOrColFromSelection(prevSelection, range_1);\n        });\n      }\n    }\n  }\n  function colSelectable(col) {\n    var colDescriptor = grid.data.col.get(col);\n    return colDescriptor && colDescriptor.selectable !== false;\n  }\n  function createHeaderSelectionRange(row, col) {\n    var headerSelectionRange;\n    if (row < 0 && col < 0) {\n      headerSelectionRange = rangeUtil.createFromPoints(0, 0, Infinity, Infinity);\n    } else if (row < 0) {\n      if (colSelectable(col)) {\n        headerSelectionRange = rangeUtil.createFromPoints(0, col, Infinity, col);\n      }\n    } else if (col < 0) {\n      headerSelectionRange = rangeUtil.createFromPoints(row, 0, row, Infinity);\n    }\n    return headerSelectionRange;\n  }\n  function addOrSetSelection(selection) {\n    if (!selectionIsFocus(model.selection)) {\n      addSelection(selection);\n    } else {\n      model.setSelection(selection);\n    }\n  }\n  function removeFullRowOrColFromSelection(selection, rowOrCol) {\n    if (rowOrCol.width === Infinity) {\n      var newSelections = [];\n      if (selection.top < rowOrCol.top) {\n        var newSelection = {\n          top: selection.top,\n          height: rowOrCol.top - selection.top,\n          left: selection.left,\n          width: selection.width\n        };\n        newSelections.push(newSelection);\n      }\n      var bottomRow = selection.top + selection.height - 1;\n      if (bottomRow > rowOrCol.top + rowOrCol.height - 1) {\n        newSelections.push({\n          top: rowOrCol.top + rowOrCol.height,\n          height: bottomRow - (rowOrCol.top + rowOrCol.height - 1),\n          left: selection.left,\n          width: selection.width\n        });\n      }\n      removeSelection(selection);\n      newSelections.forEach(addOrSetSelection);\n      syncSelectionToHeaders();\n    }\n    if (rowOrCol.height === Infinity) {}\n  }\n  function findFullRowOrColSelections(range) {\n    return model.getAllSelections().filter(function (selection) {\n      return selection.height === Infinity && selection.top === 0 && rangeUtil.intersect([selection.left, selection.width], [range.left, range.width]) || selection.width === Infinity && selection.left === 0 && rangeUtil.intersect([selection.top, selection.height], [range.top, range.height]);\n    });\n  }\n  function addSelection(range) {\n    model.otherSelections.push(createAndAddSelectionDecorator(range.top, range.left, range.height, range.width));\n  }\n  function handleRowColSelectionChange(rowOrCol) {\n    var decoratorsField = rowOrCol === 'row' ? '_rowSelectionClasses' : '_colSelectionClasses';\n    var rowColModelField = rowOrCol === 'row' ? 'rowModel' : 'colModel';\n    model[decoratorsField].forEach(function (selectionDecorator) {\n      grid.cellClasses.remove(selectionDecorator);\n    });\n    model[decoratorsField] = [];\n    if (grid[rowColModelField].allSelected()) {\n      var top_1 = rowOrCol === 'row' ? Infinity : 0;\n      var left = rowOrCol === 'col' ? Infinity : 0;\n      var decorator = grid.cellClasses.create(top_1, left, 'selected', 1, 1, 'virtual');\n      grid.cellClasses.add(decorator);\n      model[decoratorsField].push(decorator);\n    } else {\n      grid[rowColModelField].getSelected().forEach(function (index) {\n        var virtualIndex = grid[rowColModelField].toVirtual(index);\n        var top = rowOrCol === 'row' ? virtualIndex : 0;\n        var left = rowOrCol === 'col' ? virtualIndex : 0;\n        var decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');\n        grid.cellClasses.add(decorator);\n        model[decoratorsField].push(decorator);\n      });\n    }\n  }\n  grid.eventLoop.bind('grid-row-selection-change', function () {\n    handleRowColSelectionChange('row');\n  });\n  grid.eventLoop.bind('grid-col-selection-change', function () {\n    handleRowColSelectionChange('col');\n  });\n  function createAndAddSelectionDecorator(t, l, h, w) {\n    var selection = grid.decorators.create(t, l, h, w);\n    var defaultRender = selection.render;\n    selection.render = function () {\n      var div = defaultRender();\n      div.setAttribute('class', 'grid-selection');\n      return div;\n    };\n    grid.decorators.add(selection);\n    return selection;\n  }\n  function syncSelectionToHeaders() {\n    grid.colModel.clearSelected();\n    grid.rowModel.clearSelected();\n    model.getAllSelections().forEach(function (s) {\n      if (s) {\n        maybeSelectHeaderFromSelection(s);\n      }\n    });\n  }\n  function maybeSelectHeaderFromSelection(range, deselect) {\n    var indexes;\n    if (range.top === 0 && range.height === Infinity) {\n      indexes = grid.data.col.indexes({\n        from: range.left,\n        length: range.width\n      });\n      if (deselect) {\n        grid.colModel.deselect(indexes);\n      } else {\n        grid.colModel.select(indexes);\n      }\n    }\n    if (range.left === 0 && range.width === Infinity) {\n      indexes = grid.data.row.indexes({\n        from: range.top,\n        length: range.height\n      });\n      if (deselect) {\n        grid.rowModel.deselect(indexes);\n      } else {\n        grid.rowModel.select(indexes);\n      }\n    }\n  }\n  function selectionIsFocus(s) {\n    return s.height === 1 && s.width === 1 && !model.otherSelections.length;\n  }\n  function setSelectionToFocus() {\n    model.setSelection({\n      top: model.focus.row,\n      left: model.focus.col,\n      height: 1,\n      width: 1\n    });\n  }\n  function clearOtherSelections() {\n    grid.decorators.remove(model.otherSelections);\n    model.otherSelections = [];\n    syncSelectionToHeaders();\n  }\n  function isDecorator(s) {\n    return !!s.space;\n  }\n  function removeSelection(selectionToRemove) {\n    if (rangeUtil.equal(selectionToRemove, model.selection)) {\n      if (model.otherSelections.length) {\n        var lastSelection = model.otherSelections.pop();\n        grid.decorators.remove(lastSelection);\n        model.setSelection(lastSelection);\n      } else {\n        setSelectionToFocus();\n      }\n    } else if (isDecorator(selectionToRemove)) {\n      var index = model.otherSelections.indexOf(selectionToRemove);\n      if (index !== -1) {\n        model.otherSelections.splice(index, 1);\n        grid.decorators.remove(selectionToRemove);\n      }\n    }\n    syncSelectionToHeaders();\n  }\n  function setSelectionFromPoints(fromRow, fromCol, toRow, toCol, dontClearOthers) {\n    if (!dontClearOthers) {\n      clearOtherSelections();\n    }\n    toRow = util.clamp(toRow, 0, Infinity);\n    toCol = util.clamp(toCol, 0, Infinity);\n    var newSelection = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);\n    model.setSelection(newSelection);\n  }\n  mainSelection._onDragStart = function (e) {\n    if (!isNavableMouseEvent(e)) {\n      return;\n    }\n    if (e.enableAutoScroll) {\n      e.enableAutoScroll();\n    }\n    var fromRow = model.focus.row;\n    var fromCol = model.focus.col;\n    var startCol = e.col;\n    var startRow = e.row;\n    var wasSelected;\n    var toRow;\n    var toCol;\n    if (startRow < 0) {\n      wasSelected = !grid.data.col.get(startCol).selected;\n      fromRow = 0;\n      toRow = Infinity;\n    }\n    if (startCol < 0) {\n      wasSelected = !grid.data.row.get(startRow).selected;\n      fromCol = 0;\n      toCol = Infinity;\n    }\n    var unbindDrag = grid.eventLoop.bind('grid-cell-drag', function (gridCellDrag) {\n      toRow = toRow !== Infinity ? gridCellDrag.row : toRow;\n      toCol = toCol !== Infinity ? gridCellDrag.col : toCol;\n      if (toCol !== Infinity && !colSelectable(toCol)) {\n        return;\n      }\n      var fixedRows = grid.rowModel.numFixed(true);\n      if (startRow < fixedRows && toRow > fixedRows && toRow !== Infinity) {\n        startRow = toRow = grid.rowModel.numFixed();\n        grid.cellScrollModel.scrollTo(0, grid.cellScrollModel.col);\n      }\n      var fixedCols = grid.colModel.numFixed(true);\n      if (startCol < fixedCols && toCol > fixedCols && toCol !== Infinity) {\n        startCol = toCol = grid.colModel.numFixed();\n        grid.cellScrollModel.scrollTo(grid.cellScrollModel.row, 0);\n      }\n      if (isNaN(toRow) || isNaN(toCol)) {\n        return;\n      }\n      selectFromFocusToCell(fromRow, fromCol, toRow, toCol, true, wasSelected);\n    });\n    var unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function () {\n      unbindDrag();\n      unbindDragEnd();\n    });\n  };\n  grid.eventLoop.bind('grid-drag-start', mainSelection._onDragStart);\n  setSelectionToFocus();\n  function clearSelectionFromModelChange(e) {\n    if (e.action === 'size') {\n      return;\n    }\n    model.clearSelection();\n  }\n  grid.eventLoop.bind('grid-col-change', clearSelectionFromModelChange);\n  grid.eventLoop.bind('grid-row-change', clearSelectionFromModelChange);\n  return model;\n}\nexports.create = create;\nexports.default = create;","map":{"version":3,"names":["ctrl_or_cmd_1","require","rangeUtil","util","key","arrow","code","create","grid","mainSelection","createAndAddSelectionDecorator","model","focus","row","col","selection","height","top","left","width","otherSelections","checkboxModeFor","_selectionDecorator","focusDecorator","decorators","_rowSelectionClasses","_colSelectionClasses","getAllSelections","selections","push","concat","setFocus","inputRow","inputCol","dontClearSelection","dontSetSelection","data","clamp","isNaN","changed","focusClass","cellScrollModel","scrollIntoView","clearOtherSelections","setSelectionToFocus","eventLoop","fire","_navFrom","navFrom","handleTabEvent","e","newCol","newRow","shiftKey","count","down","right","up","preventDefault","setSelection","newSelection","selectionIsFocus","syncSelectionToHeaders","getAllSelectedRanges","selectionRange","navigationModel","clearSelection","cellClasses","add","postRender","div","setAttribute","seekNextEdge","newIndex","startedDefined","isForwardEdge","isBackwardEdge","goForward","isEdgeToSeek","undefined","isSeek","default","cellHasValue_1","r","c","dataModel","get","formatted","isLeftwardEdge","isRightwardEdge","isUpwardEdge","isDownwardEdge","which","bind","focused","is","special","tab","newFocus","navFromRow","navFromCol","newRowCol","setSelectionFromPoints","isNavableMouseEvent","target","eventIsOnCells","button","isCheckboxModeForRowCol","rows","colSelectable","cols","isCheckboxMode","ctrlOrCmdPressed","fromRow","fromCol","toRow","toCol","wasSelected","colDescriptor","selectable","selected","Infinity","selectFromFocusToCell","focusRow","view","toData","rowModel","numHeaders","focusCol","colModel","headerSelectionRange_1","createHeaderSelectionRange","prevSelections","findFullRowOrColSelections","length","selectAll","allSelected","forEach","prevSelection","removeFullRowOrColFromSelection","addSelection","range_1","createFromPoints","headerSelectionRange","addOrSetSelection","rowOrCol","newSelections","bottomRow","removeSelection","range","filter","intersect","handleRowColSelectionChange","decoratorsField","rowColModelField","selectionDecorator","remove","top_1","decorator","getSelected","index","virtualIndex","toVirtual","t","l","h","w","defaultRender","render","clearSelected","s","maybeSelectHeaderFromSelection","deselect","indexes","from","select","isDecorator","space","selectionToRemove","equal","lastSelection","pop","indexOf","splice","dontClearOthers","_onDragStart","enableAutoScroll","startCol","startRow","unbindDrag","gridCellDrag","fixedRows","numFixed","scrollTo","fixedCols","unbindDragEnd","clearSelectionFromModelChange","action","exports"],"sources":["C:\\amazon\\amazon\\node_modules\\grid\\src\\modules\\navigation-model\\index.ts"],"sourcesContent":["import { IRowColEvent } from '../abstract-row-col-model';\nimport { ICellClassDescriptor } from '../cell-classes';\nimport { Grid } from '../core';\nimport ctrlOrCmd from '../ctrl-or-cmd';\nimport { IDecorator } from '../decorators';\nimport { AnnotatedMouseEventUnion, AnnotatedMouseOrKeyEventUnion, IGridCustomMouseEvent, IGridDragStartEvent } from '../event-loop';\nimport { RawPositionRange } from '../position-range';\nimport * as rangeUtil from '../range-util';\nimport * as util from '../util';\n\nconst key = require('key');\nconst arrow = key.code.arrow;\n\nexport interface ISelectionDecorator extends IDecorator {\n  top: number;\n  left: number;\n  width: number;\n  height: number;\n  _onDragStart?(e: IGridDragStartEvent): void;\n}\n\nexport interface IFocus {\n  row: number;\n  col: number;\n}\n\nexport interface INavigationModel {\n  focus: IFocus;\n  selection: RawPositionRange;\n  otherSelections: ISelectionDecorator[];\n  checkboxModeFor: {\n    rows?: boolean;\n    cols?: boolean;\n  };\n  _selectionDecorator: ISelectionDecorator;\n  focusDecorator: IDecorator;\n  _rowSelectionClasses: ICellClassDescriptor[];\n  _colSelectionClasses: ICellClassDescriptor[];\n  getAllSelections(): Array<RawPositionRange | ISelectionDecorator>;\n  getAllSelectedRanges(): RawPositionRange[];\n  clearSelection(): void;\n  setSelection(r: RawPositionRange): void;\n  setFocus(row: number | undefined, col: number | undefined, dontClearSelection?: boolean, dontSetSelection?: boolean): void;\n  _navFrom(row: number, col: number, e: AnnotatedMouseOrKeyEventUnion): IFocus;\n  handleTabEvent(e: AnnotatedMouseOrKeyEventUnion): void;\n}\n\nexport function create(grid: Grid) {\n  const mainSelection = createAndAddSelectionDecorator(0, 0, -1, -1);\n  const model: INavigationModel = {\n    focus: {\n      row: 0,\n      col: 0\n    },\n    get selection() {\n      if (mainSelection.height === -1) { // cleared selection default to focus\n        return {\n          top: model.focus.row,\n          left: model.focus.col,\n          height: 1,\n          width: 1\n        };\n      }\n      return mainSelection;\n    },\n    otherSelections: [],\n    checkboxModeFor: {},\n    _selectionDecorator: mainSelection,\n    focusDecorator: grid.decorators.create(0, 0, 1, 1),\n    _rowSelectionClasses: [],\n    _colSelectionClasses: [],\n    getAllSelections() {\n      const selections = [];\n      if (model.selection) {\n        selections.push(model.selection);\n      }\n      return selections.concat(model.otherSelections);\n    },\n    setFocus(inputRow?: number, inputCol?: number, dontClearSelection?: boolean, dontSetSelection?: boolean) {\n      inputRow = inputRow && grid.data.row.clamp(inputRow);\n      const row = (typeof inputRow !== 'number' || isNaN(inputRow)) ? model.focus.row : inputRow;\n\n      inputCol = inputCol && grid.data.col.clamp(inputCol);\n      const col = (typeof inputCol !== 'number' || isNaN(inputCol)) ? model.focus.row : inputCol;\n\n      const changed = row !== model.focus.row || col !== model.focus.col;\n      model.focus.row = row;\n      model.focus.col = col;\n      focusClass.top = row;\n      focusClass.left = col;\n      model.focusDecorator.top = row;\n      model.focusDecorator.left = col;\n      grid.cellScrollModel.scrollIntoView(row, col);\n      if (!dontClearSelection) {\n        clearOtherSelections();\n      }\n      if (!dontSetSelection) {\n        setSelectionToFocus();\n      }\n      if (changed) {\n        grid.eventLoop.fire('grid-focus-change');\n      }\n    },\n    _navFrom: navFrom,\n    handleTabEvent(e: AnnotatedMouseOrKeyEventUnion) {\n      let newCol: number | undefined = model.focus.col;\n      let newRow: number | undefined = model.focus.row;\n      if (!e || !e.shiftKey) {\n        if (newCol === grid.data.col.count() - 1) {\n          newRow = grid.data.down(newRow);\n          newCol = 0;\n        } else {\n          newCol = grid.data.right(newCol);\n        }\n      } else {\n        if (newCol === 0) {\n          newRow = grid.data.up(newRow);\n          newCol = grid.data.col.count() - 1;\n        } else {\n          newCol = grid.data.left(newCol);\n        }\n      }\n      model.setFocus(newRow, newCol);\n      e.preventDefault();\n    },\n    setSelection(newSelection: RawPositionRange) {\n      let height = newSelection.height;\n      let width = newSelection.width;\n      if (selectionIsFocus(newSelection)) {\n        height = -1;\n        width = -1;\n      }\n      mainSelection.top = newSelection.top;\n      mainSelection.left = newSelection.left;\n      mainSelection.height = height;\n      mainSelection.width = width;\n      // select the columns to match\n      syncSelectionToHeaders();\n    },\n    getAllSelectedRanges() {\n      let selectionRange = grid.navigationModel.selection;\n      // valid selection range cannot go to -1\n      if (selectionRange.top === -1) {\n        selectionRange = {\n          top: grid.navigationModel.focus.row,\n          left: grid.navigationModel.focus.col,\n          width: 1,\n          height: 1\n        };\n      }\n      return [selectionRange].concat(model.otherSelections);\n    },\n\n    clearSelection() {\n      clearOtherSelections();\n      setSelectionToFocus();\n    },\n  };\n\n  const focusClass = grid.cellClasses.create(0, 0, 'focus');\n  grid.cellClasses.add(focusClass);\n\n  model.focusDecorator.postRender = (div) => {\n    div.setAttribute('class', 'grid-focus-decorator');\n    return div;\n  };\n  grid.decorators.add(model.focusDecorator);\n\n  function seekNextEdge(\n    newIndex: number | undefined,\n    startedDefined: boolean,\n    isForwardEdge: (i?: number) => boolean,\n    isBackwardEdge: (i?: number) => boolean,\n    goForward: (i: number) => number | undefined\n  ) {\n    const isEdgeToSeek = (isForwardEdge(newIndex) || !startedDefined) &&\n      isBackwardEdge ||\n      isForwardEdge;\n\n    // tslint:disable-next-line:no-conditional-assignment\n    while (newIndex !== undefined && goForward(newIndex) !== undefined && !isEdgeToSeek(newIndex = goForward(newIndex))) {\n      // empty\n    }\n\n    return newIndex;\n  }\n\n  function navFrom(row: number, col: number, e: AnnotatedMouseOrKeyEventUnion) {\n    // if nothing changes great we'll stay where we are\n    let newRow: number | undefined = row;\n    let newCol: number | undefined = col;\n    const isSeek = ctrlOrCmd(e);\n    // tslint:disable-next-line:one-variable-per-declaration\n    if (isSeek) {\n      const cellHasValue = (r?: number, c?: number) => {\n        if (r === undefined || c === undefined) {\n          return false;\n        }\n\n        return !!grid.dataModel.get(r, c).formatted;\n      };\n      const isLeftwardEdge = (c: number) => {\n        return cellHasValue(newRow, c) && !cellHasValue(newRow, grid.data.left(c));\n      };\n      const isRightwardEdge = (c: number) => {\n        return cellHasValue(newRow, c) && !cellHasValue(newRow, grid.data.right(c));\n      };\n      const isUpwardEdge = (r: number) => {\n        return cellHasValue(r, newCol) && !cellHasValue(grid.data.up(r), newCol);\n      };\n      const isDownwardEdge = (r: number) => {\n        return cellHasValue(r, newCol) && !cellHasValue(grid.data.down(r), newCol);\n      };\n      const startedDefined = cellHasValue(newRow, newCol);\n      switch (e.which) {\n        case arrow.down.code:\n          newRow = seekNextEdge(newRow, startedDefined, isDownwardEdge, isUpwardEdge, grid.data.down);\n          break;\n        case arrow.up.code:\n          newRow = seekNextEdge(newRow, startedDefined, isUpwardEdge, isDownwardEdge, grid.data.up);\n          break;\n        case arrow.right.code:\n          newCol = seekNextEdge(newCol, startedDefined, isRightwardEdge, isLeftwardEdge, grid.data.right);\n          break;\n        case arrow.left.code:\n          newCol = seekNextEdge(newCol, startedDefined, isLeftwardEdge, isRightwardEdge, grid.data.left);\n          break;\n      }\n    } else {\n      switch (e.which) {\n        case arrow.down.code:\n          newRow = grid.data.down(newRow);\n          break;\n        case arrow.up.code:\n          newRow = grid.data.up(newRow);\n          break;\n        case arrow.right.code:\n          newCol = grid.data.right(newCol);\n          break;\n        case arrow.left.code:\n          newCol = grid.data.left(newCol);\n          break;\n      }\n    }\n\n    if (newRow === undefined) {\n      newRow = row;\n    }\n    if (newCol === undefined) {\n      newCol = col;\n    }\n    return {\n      row: newRow,\n      col: newCol\n    };\n\n  }\n\n  grid.eventLoop.bind('keydown', (e) => {\n    if (!grid.focused) {\n      return;\n    }\n    // handle tab\n    if (key.is(key.code.special.tab, e.which)) {\n      model.handleTabEvent(e);\n      return;\n    }\n\n    if (!key.is(arrow, e.which)) {\n      return;\n    }\n    // focus logic\n\n    if (!e.shiftKey) {\n      const newFocus = navFrom(model.focus.row, model.focus.col, e);\n      model.setFocus(newFocus.row, newFocus.col, true);\n    } else {\n      // selection logic\n      let newSelection;\n      // stand in for if it's cleared\n      if (model.selection.top === -1) {\n        newSelection = {\n          top: model.focus.row,\n          left: model.focus.col,\n          height: 1,\n          width: 1\n        };\n      } else {\n        newSelection = {\n          top: model.selection.top,\n          left: model.selection.left,\n          height: model.selection.height,\n          width: model.selection.width\n        };\n      }\n      const navFromRow = (model.focus.row === newSelection.top) ?\n        newSelection.top + newSelection.height - 1 :\n        newSelection.top;\n\n      const navFromCol = (model.focus.col === newSelection.left) ?\n        newSelection.left + newSelection.width - 1 :\n        newSelection.left;\n      const newRowCol = navFrom(navFromRow, navFromCol, e);\n      setSelectionFromPoints(model.focus.row, model.focus.col, newRowCol.row, newRowCol.col);\n      grid.cellScrollModel.scrollIntoView(newRowCol.row, newRowCol.col);\n    }\n  });\n\n  function isNavableMouseEvent(e: AnnotatedMouseEventUnion | IGridCustomMouseEvent) {\n    const target = e.target;\n    // if there's no target let it through because that only happens in unit tests,\n    // or if it happened in real world it wouldn't have a valid row or col and so wouldn't do anything anyway\n    return !target || grid.eventIsOnCells(e) && (e as AnnotatedMouseEventUnion).button !== 2;\n  }\n\n  function isCheckboxModeForRowCol(row: number, col: number) {\n    return model.checkboxModeFor.rows && col < 0 || (row < 0 && colSelectable(col)) && model.checkboxModeFor.cols;\n  }\n\n  grid.eventLoop.bind('mousedown', (e) => {\n    if (!isNavableMouseEvent(e)) {\n      return;\n    }\n    // assume the event has been annotated by the cell mouse model interceptor\n    const row = e.row;\n    const col = e.col;\n\n    // if we're in checkbox mode pretend the user held command for header mousedowns only\n    const isCheckboxMode = isCheckboxModeForRowCol(row, col);\n    const ctrlOrCmdPressed = isCheckboxMode || ctrlOrCmd(e);\n\n    if (e.shiftKey) {\n      let fromRow = model.focus.row;\n      let fromCol = model.focus.col;\n      let toRow = row;\n      let toCol = col;\n      let wasSelected;\n      if (toRow < 0) {\n        const colDescriptor = grid.data.col.get(toCol);\n        if (colDescriptor.selectable !== false) {\n          wasSelected = colDescriptor.selected;\n          fromRow = 0;\n          toRow = Infinity;\n        }\n\n      }\n      if (toCol < 0) {\n        wasSelected = grid.data.row.get(toRow).selected;\n        fromCol = 0;\n        toCol = Infinity;\n      }\n\n      selectFromFocusToCell(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed, wasSelected);\n    } else {\n\n      let focusRow = row;\n      if (focusRow < 0) {\n        focusRow = grid.view.row.toData(grid.rowModel.numHeaders());\n      }\n      let focusCol = col;\n      if (focusCol < 0) {\n        focusCol = grid.view.col.toData(grid.colModel.numHeaders());\n      }\n\n      const headerSelectionRange = createHeaderSelectionRange(row, col);\n      if (headerSelectionRange) {\n        const prevSelections = findFullRowOrColSelections(headerSelectionRange);\n        if (prevSelections.length && isCheckboxMode) {\n          const selectAll = headerSelectionRange.width === Infinity &&\n            headerSelectionRange.height === Infinity &&\n            !(grid.rowModel.allSelected() || grid.colModel.allSelected());\n          prevSelections.forEach((prevSelection) => {\n            removeFullRowOrColFromSelection(prevSelection, headerSelectionRange);\n          });\n          if (selectAll) {\n            model.setSelection(headerSelectionRange);\n          }\n          model.setFocus(focusRow, focusCol, true, true);\n        } else {\n          if (ctrlOrCmdPressed && !selectionIsFocus(model.selection)) {\n            addSelection(model.selection);\n          } else {\n            clearOtherSelections();\n          }\n          model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);\n          model.setSelection(headerSelectionRange);\n        }\n\n      } else {\n        if (ctrlOrCmdPressed) {\n          addSelection(model.selection);\n        }\n        model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);\n      }\n    }\n  });\n\n  function selectFromFocusToCell(\n    fromRow: number,\n    fromCol: number,\n    toRow: number,\n    toCol: number,\n    ctrlOrCmdPressed: boolean,\n    wasSelected?: boolean\n  ) {\n    const isCheckboxMode = (fromRow === 0 && toRow === Infinity && model.checkboxModeFor.cols) ||\n      (fromCol === 0 && toCol === Infinity && model.checkboxModeFor.rows);\n    if (!wasSelected || !isCheckboxMode) {\n      setSelectionFromPoints(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed);\n    } else {\n      const range = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);\n      const prevSelections = findFullRowOrColSelections(range);\n      if (prevSelections.length) {\n        prevSelections.forEach((prevSelection) => {\n          removeFullRowOrColFromSelection(prevSelection, range);\n        });\n      }\n    }\n  }\n\n  function colSelectable(col: number) {\n    const colDescriptor = grid.data.col.get(col);\n    return colDescriptor && colDescriptor.selectable !== false;\n  }\n\n  function createHeaderSelectionRange(row: number, col: number) {\n    let headerSelectionRange;\n    if (row < 0 && col < 0) {\n      headerSelectionRange = rangeUtil.createFromPoints(0, 0, Infinity, Infinity);\n    } else if (row < 0) {\n      if (colSelectable(col)) {\n        headerSelectionRange = rangeUtil.createFromPoints(0, col, Infinity, col);\n      }\n    } else if (col < 0) {\n      headerSelectionRange = rangeUtil.createFromPoints(row, 0, row, Infinity);\n    }\n    return headerSelectionRange;\n  }\n\n  function addOrSetSelection(selection: RawPositionRange) {\n    if (!selectionIsFocus(model.selection)) {\n      addSelection(selection);\n    } else {\n      model.setSelection(selection);\n    }\n  }\n\n  function removeFullRowOrColFromSelection(selection: RawPositionRange | ISelectionDecorator, rowOrCol: RawPositionRange) {\n\n    if (rowOrCol.width === Infinity) { // row\n      const newSelections = [];\n      if (selection.top < rowOrCol.top) { // we need a selection for the top portion\n        const newSelection = {\n          top: selection.top,\n          height: rowOrCol.top - selection.top,\n          left: selection.left,\n          width: selection.width\n        };\n        newSelections.push(newSelection);\n      }\n\n      const bottomRow = selection.top + selection.height - 1;\n      if (bottomRow > rowOrCol.top + rowOrCol.height - 1) { // we need a selection for the bottom portion\n        newSelections.push({\n          top: rowOrCol.top + rowOrCol.height,\n          height: bottomRow - (rowOrCol.top + rowOrCol.height - 1),\n          left: selection.left,\n          width: selection.width\n        });\n      }\n      removeSelection(selection);\n      newSelections.forEach(addOrSetSelection);\n      syncSelectionToHeaders();\n    }\n\n    if (rowOrCol.height === Infinity) {\n      // TODO: col\n    }\n  }\n\n  function findFullRowOrColSelections(range: RawPositionRange) {\n    return model.getAllSelections().filter((selection) => {\n      return (selection.height === Infinity &&\n        selection.top === 0 &&\n        rangeUtil.intersect([selection.left, selection.width], [range.left, range.width]))\n        ||\n        (selection.width === Infinity &&\n          selection.left === 0 &&\n          rangeUtil.intersect([selection.top, selection.height], [range.top, range.height]));\n    });\n  }\n\n  function addSelection(range: RawPositionRange) {\n    model.otherSelections.push(createAndAddSelectionDecorator(range.top, range.left, range.height, range.width));\n  }\n\n  // row col selection\n  function handleRowColSelectionChange(rowOrCol: 'row' | 'col') {\n    const decoratorsField = rowOrCol === 'row' ? '_rowSelectionClasses' : '_colSelectionClasses';\n    const rowColModelField = rowOrCol === 'row' ? 'rowModel' : 'colModel';\n    model[decoratorsField].forEach((selectionDecorator) => {\n      grid.cellClasses.remove(selectionDecorator);\n    });\n    model[decoratorsField] = [];\n\n    if (grid[rowColModelField].allSelected()) {\n      const top = rowOrCol === 'row' ? Infinity : 0;\n      const left = rowOrCol === 'col' ? Infinity : 0;\n      const decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');\n      grid.cellClasses.add(decorator);\n      model[decoratorsField].push(decorator);\n    } else {\n      grid[rowColModelField].getSelected().forEach((index) => {\n        const virtualIndex = grid[rowColModelField].toVirtual(index);\n        const top = rowOrCol === 'row' ? virtualIndex : 0;\n        const left = rowOrCol === 'col' ? virtualIndex : 0;\n        const decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');\n        grid.cellClasses.add(decorator);\n        model[decoratorsField].push(decorator);\n      });\n    }\n  }\n\n  grid.eventLoop.bind('grid-row-selection-change', () => {\n    handleRowColSelectionChange('row');\n  });\n\n  grid.eventLoop.bind('grid-col-selection-change', () => {\n    handleRowColSelectionChange('col');\n  });\n\n  function createAndAddSelectionDecorator(t: number, l: number, h: number, w: number): ISelectionDecorator {\n    const selection = grid.decorators.create(t, l, h, w);\n    const defaultRender = selection.render;\n    selection.render = () => {\n      const div = defaultRender();\n      div.setAttribute('class', 'grid-selection');\n      return div;\n    };\n    grid.decorators.add(selection);\n    return selection as ISelectionDecorator;\n  }\n\n  function syncSelectionToHeaders() {\n    grid.colModel.clearSelected();\n    grid.rowModel.clearSelected();\n    model.getAllSelections().forEach((s) => {\n      if (s) {\n        maybeSelectHeaderFromSelection(s);\n      }\n    });\n  }\n\n  function maybeSelectHeaderFromSelection(range: RawPositionRange, deselect?: boolean) {\n    let indexes;\n    if (range.top === 0 && range.height === Infinity) {\n      indexes = grid.data.col.indexes({\n        from: range.left,\n        length: range.width\n      });\n      if (deselect) {\n        grid.colModel.deselect(indexes);\n      } else {\n        grid.colModel.select(indexes);\n      }\n    }\n    if (range.left === 0 && range.width === Infinity) {\n      indexes = grid.data.row.indexes({\n        from: range.top,\n        length: range.height\n      });\n      if (deselect) {\n        grid.rowModel.deselect(indexes);\n      } else {\n        grid.rowModel.select(indexes);\n      }\n    }\n  }\n\n  function selectionIsFocus(s: RawPositionRange) {\n    return s.height === 1 && s.width === 1 && !model.otherSelections.length;\n  }\n\n  function setSelectionToFocus() {\n    model.setSelection({\n      top: model.focus.row,\n      left: model.focus.col,\n      height: 1,\n      width: 1\n    });\n  }\n\n  function clearOtherSelections() {\n    grid.decorators.remove(model.otherSelections);\n    model.otherSelections = [];\n    syncSelectionToHeaders();\n  }\n\n  function isDecorator(s: ISelectionDecorator | RawPositionRange): s is ISelectionDecorator {\n    return !!(s as ISelectionDecorator).space;\n  }\n\n  function removeSelection(selectionToRemove: ISelectionDecorator | RawPositionRange) {\n    if (rangeUtil.equal(selectionToRemove, model.selection)) {\n      if (model.otherSelections.length) {\n        const lastSelection = model.otherSelections.pop() as ISelectionDecorator;\n        grid.decorators.remove(lastSelection);\n        model.setSelection(lastSelection);\n      } else {\n        setSelectionToFocus();\n      }\n    } else if (isDecorator(selectionToRemove)) {\n      const index = model.otherSelections.indexOf(selectionToRemove);\n      if (index !== -1) {\n        model.otherSelections.splice(index, 1);\n        grid.decorators.remove(selectionToRemove);\n      }\n    }\n    syncSelectionToHeaders();\n  }\n\n  function setSelectionFromPoints(fromRow: number, fromCol: number, toRow: number, toCol: number, dontClearOthers?: boolean) {\n    if (!dontClearOthers) {\n      clearOtherSelections();\n    }\n    toRow = util.clamp(toRow, 0, Infinity);\n    toCol = util.clamp(toCol, 0, Infinity);\n    const newSelection = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);\n    model.setSelection(newSelection);\n  }\n\n  mainSelection._onDragStart = (e) => {\n    if (!isNavableMouseEvent(e)) {\n      return;\n    }\n    if (e.enableAutoScroll) {\n      e.enableAutoScroll();\n    }\n    let fromRow = model.focus.row;\n    let fromCol = model.focus.col;\n    let startCol = e.col;\n    let startRow = e.row;\n    let wasSelected: boolean | undefined;\n    let toRow: number | undefined;\n    let toCol: number | undefined;\n    if (startRow < 0) {\n      // these are notted because mousedwon actually inverts the intial selection\n      wasSelected = !grid.data.col.get(startCol).selected;\n      fromRow = 0;\n      toRow = Infinity;\n\n    }\n    if (startCol < 0) {\n      // these are notted because mousedwon actually inverts the intial selection\n      wasSelected = !grid.data.row.get(startRow).selected;\n      fromCol = 0;\n      toCol = Infinity;\n    }\n    const unbindDrag = grid.eventLoop.bind('grid-cell-drag', (gridCellDrag) => {\n      toRow = toRow !== Infinity ? gridCellDrag.row : toRow;\n      toCol = toCol !== Infinity ? gridCellDrag.col : toCol;\n      if (toCol !== Infinity && !colSelectable(toCol)) {\n        return;\n      }\n\n      const fixedRows = grid.rowModel.numFixed(true);\n      if (startRow < fixedRows && toRow > fixedRows && toRow !== Infinity) {\n        startRow = toRow = grid.rowModel.numFixed();\n        grid.cellScrollModel.scrollTo(0, grid.cellScrollModel.col);\n      }\n      const fixedCols = grid.colModel.numFixed(true);\n      if (startCol < fixedCols && toCol > fixedCols && toCol !== Infinity) {\n        startCol = toCol = grid.colModel.numFixed();\n        grid.cellScrollModel.scrollTo(grid.cellScrollModel.row, 0);\n      }\n      if (isNaN(toRow) || isNaN(toCol)) {\n        return; // don't try to select when NaN\n      }\n      // always pass true because if it was to be cleared mousedown should have handled that\n      selectFromFocusToCell(fromRow, fromCol, toRow, toCol, true, wasSelected);\n    });\n    const unbindDragEnd = grid.eventLoop.bind('grid-drag-end', () => {\n      unbindDrag();\n      unbindDragEnd();\n    });\n  };\n  grid.eventLoop.bind('grid-drag-start', mainSelection._onDragStart);\n\n  setSelectionToFocus();\n\n  function clearSelectionFromModelChange(e: IRowColEvent) {\n    if (e.action === 'size') { // don't clear for resize but all other changes for now will clear selection\n      return;\n    }\n    model.clearSelection();\n\n  }\n\n  grid.eventLoop.bind('grid-col-change', clearSelectionFromModelChange);\n  grid.eventLoop.bind('grid-row-change', clearSelectionFromModelChange);\n  return model;\n}\n\nexport default create;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}