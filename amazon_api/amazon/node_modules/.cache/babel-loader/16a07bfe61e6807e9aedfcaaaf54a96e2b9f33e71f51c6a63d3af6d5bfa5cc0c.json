{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = void 0;\nvar dirty_clean_1 = require(\"../dirty-clean\");\nvar util = require(\"../util\");\nfunction create(grid) {\n  var dirtyClean = dirty_clean_1.default(grid);\n  function makeDimension(gridDimension) {\n    function convertVirtualToScroll(virtualCoord) {\n      return virtualCoord - gridDimension.rowColModel.numFixed();\n    }\n    function getScrollToRowOrCol(virtualCoord) {\n      var currentScroll = cellScrollDimension.position;\n      var scrollTo = currentScroll;\n      if (gridDimension.viewPort.isInView(virtualCoord)) {\n        return scrollTo;\n      }\n      var targetScroll = convertVirtualToScroll(virtualCoord);\n      if (targetScroll < currentScroll) {\n        scrollTo = targetScroll;\n      } else if (targetScroll > currentScroll) {\n        var lengthToCell = gridDimension.virtualPixelCell.sizeOf(0, virtualCoord);\n        var numFixed = gridDimension.rowColModel.numFixed();\n        scrollTo = 0;\n        for (var i = numFixed; i < virtualCoord && lengthToCell > gridDimension.viewPort.size; i++) {\n          lengthToCell -= gridDimension.virtualPixelCell.sizeOf(i);\n          scrollTo = i - (numFixed - 1);\n        }\n      }\n      return scrollTo;\n    }\n    var cellScrollDimension = {\n      position: 0,\n      scrollTo: function (position, dontFire) {\n        var maxPosition = (gridDimension.rowColModel.length() || 1) - 1;\n        var lastPosition = cellScrollDimension.position;\n        cellScrollDimension.position = util.clamp(position, 0, maxPosition);\n        if (lastPosition !== cellScrollDimension.position) {\n          dirtyClean.setDirty();\n          if (!dontFire) {\n            notifyListeners();\n          }\n          return true;\n        }\n        return false;\n      },\n      getPixelScroll: function () {\n        return gridDimension.virtualPixelCell.sizeOf(gridDimension.rowColModel.numFixed(), cellScrollDimension.position + gridDimension.rowColModel.numFixed() - 1);\n      },\n      getScrollIntoViewCell: function (dataCell) {\n        var virtualCell = gridDimension.converters.virtual.clamp(gridDimension.converters.data.toVirtual(dataCell));\n        return getScrollToRowOrCol(virtualCell);\n      }\n    };\n    return cellScrollDimension;\n  }\n  var model = {\n    get col() {\n      return model.colInfo.position;\n    },\n    get row() {\n      return model.rowInfo.position;\n    },\n    isDirty: dirtyClean.isDirty,\n    rowInfo: makeDimension(grid.rows),\n    colInfo: makeDimension(grid.cols),\n    scrollTo: function (r, c, dontFire, dontNotifyPixelModel) {\n      if (isNaN(r) || isNaN(c)) {\n        return;\n      }\n      var rowScrollChange = model.rowInfo.scrollTo(r, true);\n      var colScrollChange = model.colInfo.scrollTo(c, true);\n      if (rowScrollChange || colScrollChange) {\n        if (!dontFire) {\n          notifyListeners(dontNotifyPixelModel);\n        }\n      }\n    },\n    scrollIntoView: function (dataRow, dataCol) {\n      var newRow = model.rowInfo.getScrollIntoViewCell(dataRow);\n      var newCol = model.colInfo.getScrollIntoViewCell(dataCol);\n      model.scrollTo(newRow, newCol);\n    }\n  };\n  function notifyListeners(dontNotifyPixelModel) {\n    grid.eventLoop.fire('grid-cell-scroll');\n    if (!dontNotifyPixelModel) {\n      grid.pixelScrollModel.scrollTo(model.rowInfo.getPixelScroll(), model.colInfo.getPixelScroll(), true);\n    }\n  }\n  grid.eventLoop.bind('grid-row-change', function (e) {\n    switch (e.action) {\n      case 'remove':\n        model.scrollTo(0, model.col);\n        break;\n    }\n  });\n  return model;\n}\nexports.create = create;\nexports.default = create;","map":{"version":3,"names":["dirty_clean_1","require","util","create","grid","dirtyClean","default","makeDimension","gridDimension","convertVirtualToScroll","virtualCoord","rowColModel","numFixed","getScrollToRowOrCol","currentScroll","cellScrollDimension","position","scrollTo","viewPort","isInView","targetScroll","lengthToCell","virtualPixelCell","sizeOf","i","size","dontFire","maxPosition","length","lastPosition","clamp","setDirty","notifyListeners","getPixelScroll","getScrollIntoViewCell","dataCell","virtualCell","converters","virtual","data","toVirtual","model","col","colInfo","row","rowInfo","isDirty","rows","cols","r","c","dontNotifyPixelModel","isNaN","rowScrollChange","colScrollChange","scrollIntoView","dataRow","dataCol","newRow","newCol","eventLoop","fire","pixelScrollModel","bind","e","action","exports"],"sources":["C:\\amazon\\amazon\\node_modules\\grid\\src\\modules\\cell-scroll-model\\index.ts"],"sourcesContent":["import { Grid, IGridDimension } from '../core';\nimport makeDirtyClean from '../dirty-clean';\nimport * as util from '../util';\n\nexport interface ICellScrollDimension {\n    position: number;\n    scrollTo(position: number, dontFire?: boolean): boolean;\n    getPixelScroll(): number;\n    getScrollIntoViewCell(dataCell: number): number;\n}\n\nexport interface ICellScrollModel {\n    col: number;\n    row: number;\n    rowInfo: ICellScrollDimension;\n    colInfo: ICellScrollDimension;\n    isDirty(): void;\n    scrollTo(r: number, c: number, dontFire?: boolean, dontNotifyPixelModel?: boolean): void;\n    scrollIntoView(dataRow: number, dataCol: number): void;\n}\n\nexport function create(grid: Grid) {\n    const dirtyClean = makeDirtyClean(grid);\n\n    function makeDimension(gridDimension: IGridDimension) {\n        function convertVirtualToScroll(virtualCoord: number) {\n            return virtualCoord - gridDimension.rowColModel.numFixed();\n        }\n\n        function getScrollToRowOrCol(virtualCoord: number) {\n            const currentScroll = cellScrollDimension.position;\n            let scrollTo = currentScroll;\n            if (gridDimension.viewPort.isInView(virtualCoord)) {\n                return scrollTo;\n            }\n\n            const targetScroll = convertVirtualToScroll(virtualCoord);\n            if (targetScroll < currentScroll) {\n                scrollTo = targetScroll;\n            } else if (targetScroll > currentScroll) {\n                let lengthToCell = gridDimension.virtualPixelCell.sizeOf(0, virtualCoord);\n                const numFixed = gridDimension.rowColModel.numFixed();\n                scrollTo = 0;\n                for (let i = numFixed; i < virtualCoord && lengthToCell > gridDimension.viewPort.size; i++) {\n                    lengthToCell -= gridDimension.virtualPixelCell.sizeOf(i);\n                    scrollTo = i - (numFixed - 1);\n                }\n            }\n\n            return scrollTo;\n        }\n        const cellScrollDimension: ICellScrollDimension = {\n            position: 0,\n            scrollTo(position: number, dontFire?: boolean): boolean {\n                const maxPosition = (gridDimension.rowColModel.length() || 1) - 1;\n                const lastPosition = cellScrollDimension.position;\n                cellScrollDimension.position = util.clamp(position, 0, maxPosition);\n                if (lastPosition !== cellScrollDimension.position) {\n                    dirtyClean.setDirty();\n\n                    if (!dontFire) {\n                        notifyListeners();\n                    }\n                    return true;\n                }\n                return false;\n            },\n            getPixelScroll() {\n                return gridDimension.virtualPixelCell.sizeOf(\n                    gridDimension.rowColModel.numFixed(),\n                    cellScrollDimension.position + gridDimension.rowColModel.numFixed() - 1\n                );\n            },\n            getScrollIntoViewCell(dataCell: number) {\n                const virtualCell = gridDimension.converters.virtual.clamp(gridDimension.converters.data.toVirtual(dataCell));\n                return getScrollToRowOrCol(virtualCell);\n            }\n        };\n        return cellScrollDimension;\n    }\n\n    const model: ICellScrollModel = {\n        get col() {\n            return model.colInfo.position;\n        },\n        get row() {\n            return model.rowInfo.position;\n        },\n        isDirty: dirtyClean.isDirty,\n        rowInfo: makeDimension(grid.rows),\n        colInfo: makeDimension(grid.cols),\n        scrollTo(r: number, c: number, dontFire?: boolean, dontNotifyPixelModel?: boolean) {\n            if (isNaN(r) || isNaN(c)) {\n                return;\n            }\n\n            const rowScrollChange = model.rowInfo.scrollTo(r, true);\n            const colScrollChange = model.colInfo.scrollTo(c, true);\n            if (rowScrollChange || colScrollChange) {\n                if (!dontFire) {\n                    notifyListeners(dontNotifyPixelModel);\n                }\n            }\n        },\n        scrollIntoView(dataRow: number, dataCol: number) {\n            const newRow = model.rowInfo.getScrollIntoViewCell(dataRow);\n            const newCol = model.colInfo.getScrollIntoViewCell(dataCol);\n            model.scrollTo(newRow, newCol);\n        }\n    };\n\n    function notifyListeners(dontNotifyPixelModel?: boolean) {\n        grid.eventLoop.fire('grid-cell-scroll');\n\n        if (!dontNotifyPixelModel) {\n            grid.pixelScrollModel.scrollTo(model.rowInfo.getPixelScroll(), model.colInfo.getPixelScroll(), true);\n        }\n    }\n\n    grid.eventLoop.bind('grid-row-change', (e) => {\n        switch (e.action) {\n            case 'remove':\n                model.scrollTo(0, model.col);\n                break;\n        }\n    });\n\n    return model;\n}\n\nexport default create;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}