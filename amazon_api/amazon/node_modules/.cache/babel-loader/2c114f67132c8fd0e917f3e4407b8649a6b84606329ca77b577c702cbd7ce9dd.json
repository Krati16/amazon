{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = void 0;\nvar dirty_clean_1 = require(\"../dirty-clean\");\nvar nullResult = {\n  value: null,\n  formatted: ''\n};\nvar loadingResult = {\n  value: null,\n  formatted: 'Loading...'\n};\nfunction create(grid, loadRows) {\n  var dirtyClean = dirty_clean_1.default(grid);\n  var getData = function (vR, vC) {\n    var cachedRow = getCachedRow(vR);\n    if (cachedRow) {\n      return __assign({\n        formatted: ''\n      }, cachedRow[vC]);\n    }\n    if (loadRows) {\n      return grid.cols.converters.virtual.toData(vC) === 0 ? loadingResult : nullResult;\n    }\n    return nullResult;\n  };\n  var getCachedRow = function (vR) {\n    var rowDescriptor = grid.rowModel.get(vR);\n    return rowDescriptor && rowDescriptor.data;\n  };\n  function maybeLoadRows() {\n    return __awaiter(this, void 0, void 0, function () {\n      var extras, visibles, numVisibleRows, currentTopRow, currentBottomRow, row, toFetchSet, toFetch;\n      return __generator(this, function (_a) {\n        if (!loadRows) {\n          return [2];\n        }\n        extras = [];\n        visibles = [];\n        numVisibleRows = grid.viewPort.rows;\n        currentTopRow = grid.cellScrollModel.row;\n        currentBottomRow = currentTopRow + numVisibleRows;\n        for (row = Math.max(0, currentTopRow - numVisibleRows); row < Math.min(currentBottomRow + 1 + numVisibleRows, grid.rows.converters.data.count()); row++) {\n          if (getCachedRow(grid.rows.converters.data.toVirtual(row))) {\n            continue;\n          }\n          if (row >= currentBottomRow) {\n            extras.push(row);\n          } else {\n            visibles.push(row);\n          }\n        }\n        if (!extras.length && !visibles.length) {\n          return [2];\n        }\n        if (!visibles.length && extras.length < numVisibleRows / 2) {\n          return [2];\n        }\n        toFetchSet = new Set(visibles);\n        extras.forEach(function (r) {\n          return toFetchSet.add(r);\n        });\n        toFetch = Array.from(toFetchSet);\n        if (!toFetch.length) {\n          return [2];\n        }\n        loadRows(toFetch);\n        return [2];\n      });\n    });\n  }\n  grid.eventLoop.bind('grid-cell-scroll', function () {\n    maybeLoadRows();\n  });\n  grid.eventLoop.bind('grid-viewport-change', function () {\n    maybeLoadRows();\n  });\n  return {\n    isDirty: dirtyClean.isDirty,\n    setDirty: dirtyClean.setDirty,\n    handleCachedDataChange: function () {\n      dirtyClean.setDirty();\n      maybeLoadRows();\n    },\n    get: function (dataRow, dataCol) {\n      return getData(grid.rows.converters.data.toVirtual(dataRow), grid.cols.converters.data.toVirtual(dataCol));\n    },\n    getHeader: function (virtualRow, virtualCol) {\n      return getData(virtualRow, virtualCol);\n    },\n    set: function (rowOrData, c, datum) {\n      var data;\n      if (!Array.isArray(rowOrData)) {\n        if (typeof datum === 'string') {\n          datum = datum.replace('[rR]', '').replace('[cC]', '').split(' ');\n        }\n        data = [{\n          row: rowOrData,\n          col: c,\n          value: datum\n        }];\n      } else {\n        data = rowOrData;\n      }\n      data.forEach(function (change) {\n        var rowDescriptor = grid.rowModel.get(grid.rows.converters.data.toVirtual(change.row));\n        var rowData = rowDescriptor.data;\n        if (!rowData) {\n          rowData = rowDescriptor.data = [];\n        }\n        rowData[grid.cols.converters.data.toVirtual(change.col)] = {\n          value: change.value,\n          formatted: change.formatted != undefined ? change.formatted : change.value\n        };\n      });\n    }\n  };\n}\nexports.create = create;\nexports.default = create;","map":{"version":3,"names":["dirty_clean_1","require","nullResult","value","formatted","loadingResult","create","grid","loadRows","dirtyClean","default","getData","vR","vC","cachedRow","getCachedRow","__assign","cols","converters","virtual","toData","rowDescriptor","rowModel","get","data","maybeLoadRows","extras","visibles","numVisibleRows","viewPort","rows","currentTopRow","cellScrollModel","row","currentBottomRow","Math","max","min","count","toVirtual","push","length","toFetchSet","Set","forEach","r","add","toFetch","Array","from","eventLoop","bind","isDirty","setDirty","handleCachedDataChange","dataRow","dataCol","getHeader","virtualRow","virtualCol","set","rowOrData","c","datum","isArray","replace","split","col","change","rowData","undefined","exports"],"sources":["C:\\amazon\\amazon\\node_modules\\grid\\src\\modules\\data-model\\index.ts"],"sourcesContent":["import { Grid } from '../core';\nimport makeDirtyClean from '../dirty-clean';\n\nexport interface IGridDataResult<T> {\n  value: T;\n  formatted: string;\n}\n\nexport interface IGridDataChangeBody<T> {\n  value: T;\n  formatted?: string;\n}\n\nexport interface IGridDataChange<T> extends IGridDataChangeBody<T> {\n  row: number;\n  col: number;\n  paste?: boolean;\n}\n\nexport interface IDataModel {\n  isDirty(): boolean;\n  setDirty(): void;\n  handleCachedDataChange(): void;\n  get(dataRow: number, dataCol: number, isCopy?: boolean): IGridDataResult<any>;\n  getHeader(virtualRow: number, virtualCol: number): IGridDataResult<any>;\n  set(dataRow: number, dataCol: number, value: any): void;\n  set(changes: Array<IGridDataChange<any>>): void;\n  toggleSort?(c: number): void;\n}\n\nexport type RowLoader = (dataRow: number[]) => void;\n\n// untested basic data model impl\nconst nullResult = { value: null, formatted: '' };\nconst loadingResult = { value: null, formatted: 'Loading...' };\n\nexport function create(grid: Grid, loadRows?: RowLoader): IDataModel {\n  const dirtyClean = makeDirtyClean(grid);\n\n  const getData = (vR: number, vC: number) => {\n    const cachedRow = getCachedRow(vR);\n    if (cachedRow) {\n      return {\n        formatted: '',\n        ...cachedRow[vC]\n      };\n    }\n    if (loadRows) {\n      return grid.cols.converters.virtual.toData(vC) === 0 ?\n        loadingResult :\n        nullResult;\n    }\n    return nullResult;\n  };\n\n  const getCachedRow = (vR: number) => {\n    const rowDescriptor = grid.rowModel.get(vR);\n    return rowDescriptor && rowDescriptor.data;\n  };\n\n  async function maybeLoadRows() {\n    if (!loadRows) {\n      return;\n    }\n    const extras: number[] = [];\n    const visibles = [];\n    const numVisibleRows = grid.viewPort.rows;\n\n    const currentTopRow = grid.cellScrollModel.row;\n    const currentBottomRow = currentTopRow + numVisibleRows;\n    for (let row = Math.max(0, currentTopRow - numVisibleRows);\n      row < Math.min(currentBottomRow + 1 + numVisibleRows, grid.rows.converters.data.count());\n      row++) {\n      if (getCachedRow(grid.rows.converters.data.toVirtual(row))) {\n        // already have it cached\n        continue;\n      }\n      if (row >= currentBottomRow) {\n        extras.push(row);\n      } else {\n        visibles.push(row);\n      }\n    }\n\n    if (!extras.length && !visibles.length) {\n      // everything has previously been fetched\n      return;\n    }\n\n    // fetch if any visibles, or if extras > numVisibleRows / 2\n    if (!visibles.length && extras.length < (numVisibleRows / 2)) {\n      return;\n    }\n    const toFetchSet = new Set<number>(visibles);\n    extras.forEach((r) => toFetchSet.add(r));\n    const toFetch = Array.from(toFetchSet);\n    if (!toFetch.length) {\n      return;\n    }\n    loadRows(toFetch);\n  }\n\n  grid.eventLoop.bind('grid-cell-scroll', () => {\n    maybeLoadRows();\n  });\n\n  grid.eventLoop.bind('grid-viewport-change', () => {\n    maybeLoadRows();\n  });\n\n  return {\n    isDirty: dirtyClean.isDirty,\n    setDirty: dirtyClean.setDirty,\n    handleCachedDataChange() {\n      dirtyClean.setDirty();\n      // new data could include clearing rows that are in view\n      maybeLoadRows();\n    },\n    get(dataRow: number, dataCol: number) {\n      return getData(grid.rows.converters.data.toVirtual(dataRow), grid.cols.converters.data.toVirtual(dataCol));\n    },\n    getHeader(virtualRow: number, virtualCol: number) {\n      return getData(virtualRow, virtualCol);\n    },\n    set(rowOrData: number | Array<IGridDataChange<any>>, c?: number, datum?: string | string[]) {\n      let data: Array<IGridDataChange<any>>;\n      if (!Array.isArray(rowOrData)) {\n        if (typeof datum === 'string') {\n          datum = datum.replace('[rR]', '').replace('[cC]', '').split(' ');\n        }\n        data = [{\n          row: rowOrData,\n          col: c as number,\n          value: datum\n\n        }];\n      } else {\n        data = rowOrData;\n      }\n      data.forEach((change) => {\n        const rowDescriptor = grid.rowModel.get(grid.rows.converters.data.toVirtual(change.row));\n        let rowData = rowDescriptor.data;\n        if (!rowData) {\n          rowData = rowDescriptor.data = [];\n        }\n        rowData[grid.cols.converters.data.toVirtual(change.col)] = {\n          value: change.value,\n          formatted: change.formatted != undefined ? change.formatted : change.value,\n        };\n      });\n    }\n  };\n}\n\nexport default create;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}