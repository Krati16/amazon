{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = exports.stringify = void 0;\nvar stringify = function (data) {\n  var stringResult = '';\n  data.forEach(function (row, r) {\n    row.forEach(function (value, c) {\n      if (value.indexOf('\\n') !== -1 || value.indexOf('\\t') !== -1 || value.indexOf('\"') !== -1) {\n        value = '\"' + value.replace(/\"/g, '\"\"') + '\"';\n      }\n      stringResult += value;\n      if (c !== row.length - 1) {\n        stringResult += '\\t';\n      }\n    });\n    if (r !== data.length - 1) {\n      stringResult += '\\n';\n    }\n  });\n  return stringResult;\n};\nexports.stringify = stringify;\nfunction DSVToArray(strData, strDelimiter) {\n  strDelimiter = strDelimiter || ',';\n  var objPattern = new RegExp('(\\\\' + strDelimiter + '|\\\\r?\\\\n|\\\\r|^)' + '(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|' + '([^\"\\\\' + strDelimiter + '\\\\r\\\\n]+))', 'gi');\n  var arrData = [[]];\n  var arrMatches = null;\n  while (arrMatches = objPattern.exec(strData)) {\n    var strMatchedDelimiter = arrMatches[1];\n    if (strMatchedDelimiter.length && strMatchedDelimiter !== strDelimiter) {\n      arrData.push([]);\n    }\n    var strMatchedValue = void 0;\n    if (arrMatches[2]) {\n      strMatchedValue = arrMatches[2].replace(new RegExp('\"\"', 'g'), '\"');\n    } else {\n      strMatchedValue = arrMatches[3];\n    }\n    arrData[arrData.length - 1].push(strMatchedValue);\n  }\n  return (arrData[0].length || !strData) && arrData || [[strData]];\n}\nvar parse = function (stringData) {\n  return DSVToArray(stringData, '\\t');\n};\nexports.parse = parse;","map":{"version":3,"names":["stringify","data","stringResult","forEach","row","r","value","c","indexOf","replace","length","exports","DSVToArray","strData","strDelimiter","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","push","strMatchedValue","parse","stringData"],"sources":["C:\\amazon\\amazon\\node_modules\\grid\\src\\modules\\tsv\\index.ts"],"sourcesContent":["export const stringify = (data: string[][]) => {\n    let stringResult = '';\n    data.forEach((row, r) => {\n        row.forEach((value, c) => {\n            if (value.indexOf('\\n') !== -1 || value.indexOf('\\t') !== -1 || value.indexOf('\"') !== -1) {\n                // replace \" with \"\" to escape and wrap the whole value in quotes\n                value = '\"' + value.replace(/\"/g, '\"\"') + '\"';\n            }\n            stringResult += value;\n            if (c !== row.length - 1) {\n                stringResult += '\\t';\n            }\n        });\n        if (r !== data.length - 1) {\n            stringResult += '\\n';\n        }\n\n    });\n    return stringResult;\n};\n\n// ref: http://stackoverflow.com/a/1293163/2343\n// This will parse a delimited string into an array of\n// arrays. The default delimiter is the comma, but this\n// can be overriden in the second argument.\nfunction DSVToArray(strData: string, strDelimiter?: string) {\n    // Check to see if the delimiter is defined. If not,\n    // then default to comma.\n    strDelimiter = (strDelimiter || ',');\n\n    // Create a regular expression to parse the CSV values.\n    const objPattern = new RegExp(\n        (\n            // Delimiters.\n            '(\\\\' + strDelimiter + '|\\\\r?\\\\n|\\\\r|^)' +\n\n            // Quoted fields.\n            '(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|' +\n\n            // Standard fields.\n            '([^\"\\\\' + strDelimiter + '\\\\r\\\\n]+))'\n        ),\n        'gi'\n    );\n\n    // Create an array to hold our data. Give the array\n    // a default empty first row.\n    const arrData: string[][] = [\n        []\n    ];\n\n    // Create an array to hold our individual pattern\n    // matching groups.\n    let arrMatches = null;\n\n    // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n    // tslint:disable-next-line:no-conditional-assignment\n    while (arrMatches = objPattern.exec(strData)) {\n\n        // Get the delimiter that was found.\n        const strMatchedDelimiter = arrMatches[1];\n\n        // Check to see if the given delimiter has a length\n        // (is not the start of string) and if it matches\n        // field delimiter. If id does not, then we know\n        // that this delimiter is a row delimiter.\n        if (\n            strMatchedDelimiter.length &&\n            strMatchedDelimiter !== strDelimiter\n        ) {\n\n            // Since we have reached a new row of data,\n            // add an empty row to our data array.\n            arrData.push([]);\n\n        }\n\n        let strMatchedValue: string;\n\n        // Now that we have our delimiter out of the way,\n        // let's check to see which kind of value we\n        // captured (quoted or unquoted).\n        if (arrMatches[2]) {\n\n            // We found a quoted value. When we capture\n            // this value, unescape any double quotes.\n            strMatchedValue = arrMatches[2].replace(\n                new RegExp('\"\"', 'g'),\n                '\"'\n            );\n\n        } else {\n\n            // We found a non-quoted value.\n            strMatchedValue = arrMatches[3];\n\n        }\n\n        // Now that we have our value string, let's add\n        // it to the data array.\n        arrData[arrData.length - 1].push(strMatchedValue);\n    }\n\n    // Return the parsed data.\n    return (arrData[0].length || !strData) && (arrData) || [\n        [strData]\n    ];\n}\n\nexport const parse = (stringData: string) => {\n    return DSVToArray(stringData, '\\t');\n};"],"mappings":";;;;;;AAAO,IAAMA,SAAS,GAAG,SAAAA,CAACC,IAAgB;EACtC,IAAIC,YAAY,GAAG,EAAE;EACrBD,IAAI,CAACE,OAAO,CAAC,UAACC,GAAG,EAAEC,CAAC;IAChBD,GAAG,CAACD,OAAO,CAAC,UAACG,KAAK,EAAEC,CAAC;MACjB,IAAID,KAAK,CAACE,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAIF,KAAK,CAACE,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAIF,KAAK,CAACE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;QAEvFF,KAAK,GAAG,GAAG,GAAGA,KAAK,CAACG,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,GAAG;;MAEjDP,YAAY,IAAII,KAAK;MACrB,IAAIC,CAAC,KAAKH,GAAG,CAACM,MAAM,GAAG,CAAC,EAAE;QACtBR,YAAY,IAAI,IAAI;;IAE5B,CAAC,CAAC;IACF,IAAIG,CAAC,KAAKJ,IAAI,CAACS,MAAM,GAAG,CAAC,EAAE;MACvBR,YAAY,IAAI,IAAI;;EAG5B,CAAC,CAAC;EACF,OAAOA,YAAY;AACvB,CAAC;AAnBYS,OAAA,CAAAX,SAAS,GAAAA,SAAA;AAyBtB,SAASY,UAAUA,CAACC,OAAe,EAAEC,YAAqB;EAGtDA,YAAY,GAAIA,YAAY,IAAI,GAAI;EAGpC,IAAMC,UAAU,GAAG,IAAIC,MAAM,CAGrB,KAAK,GAAGF,YAAY,GAAG,iBAAiB,GAGxC,2BAA2B,GAG3B,QAAQ,GAAGA,YAAY,GAAG,YAAY,EAE1C,IAAI,CACP;EAID,IAAMG,OAAO,GAAe,CACxB,EAAE,CACL;EAID,IAAIC,UAAU,GAAG,IAAI;EAKrB,OAAOA,UAAU,GAAGH,UAAU,CAACI,IAAI,CAACN,OAAO,CAAC,EAAE;IAG1C,IAAMO,mBAAmB,GAAGF,UAAU,CAAC,CAAC,CAAC;IAMzC,IACIE,mBAAmB,CAACV,MAAM,IAC1BU,mBAAmB,KAAKN,YAAY,EACtC;MAIEG,OAAO,CAACI,IAAI,CAAC,EAAE,CAAC;;IAIpB,IAAIC,eAAe,SAAQ;IAK3B,IAAIJ,UAAU,CAAC,CAAC,CAAC,EAAE;MAIfI,eAAe,GAAGJ,UAAU,CAAC,CAAC,CAAC,CAACT,OAAO,CACnC,IAAIO,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,EACrB,GAAG,CACN;KAEJ,MAAM;MAGHM,eAAe,GAAGJ,UAAU,CAAC,CAAC,CAAC;;IAMnCD,OAAO,CAACA,OAAO,CAACP,MAAM,GAAG,CAAC,CAAC,CAACW,IAAI,CAACC,eAAe,CAAC;;EAIrD,OAAO,CAACL,OAAO,CAAC,CAAC,CAAC,CAACP,MAAM,IAAI,CAACG,OAAO,KAAMI,OAAQ,IAAI,CACnD,CAACJ,OAAO,CAAC,CACZ;AACL;AAEO,IAAMU,KAAK,GAAG,SAAAA,CAACC,UAAkB;EACpC,OAAOZ,UAAU,CAACY,UAAU,EAAE,IAAI,CAAC;AACvC,CAAC;AAFYb,OAAA,CAAAY,KAAK,GAAAA,KAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}