{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = void 0;\nvar dirty_clean_1 = require(\"../dirty-clean\");\nvar util = require(\"../util\");\nfunction create(grid) {\n  var pixelDirtyClean = dirty_clean_1.default(grid);\n  var offsetDirtyClean = dirty_clean_1.default(grid);\n  var scrollBarWidth = 10;\n  var intentionAngle = 30;\n  function makeDimension(gridDimension, gridCrossDimension) {\n    function getViewScrollSize() {\n      return gridDimension.viewPort.size - gridDimension.virtualPixelCell.fixedSize();\n    }\n    function getScrollRatioFromVirtualScrollCoords(scroll) {\n      var maxScroll = pixelScrollDimension.maxScroll;\n      var scrollRatio = scroll / maxScroll;\n      return scrollRatio;\n    }\n    function getRealScrollBarPosition(scroll) {\n      var scrollRatio = getScrollRatioFromVirtualScrollCoords(scroll);\n      var maxScrollBarScroll = getMaxScrollBarCoord();\n      var scrollBarCoord = scrollRatio * maxScrollBarScroll;\n      return scrollBarCoord + gridDimension.virtualPixelCell.fixedSize();\n    }\n    function getMaxScroll() {\n      if (pixelScrollDimension.maxIsAllTheWay) {\n        return Math.max(0, pixelScrollDimension.scrollSize - gridDimension.virtualPixelCell.sizeOf(gridDimension.rowColModel.length(true) - 1));\n      }\n      var scrollLength = pixelScrollDimension.scrollSize;\n      var viewScrollSize = getViewScrollSize();\n      if (scrollLength <= viewScrollSize) {\n        return 0;\n      }\n      var firstScrollableCell = gridDimension.rowColModel.numFixed();\n      while (scrollLength > viewScrollSize - 10 && firstScrollableCell < gridDimension.rowColModel.length(true)) {\n        scrollLength -= gridDimension.virtualPixelCell.sizeOf(firstScrollableCell);\n        firstScrollableCell++;\n      }\n      return pixelScrollDimension.scrollSize - scrollLength;\n    }\n    function getMaxScrollBarCoord() {\n      return getViewScrollSize() - (gridDimension.positionRange.getSize(pixelScrollDimension.scrollBar) || scrollBarWidth);\n    }\n    function getScrollPositionFromReal(scrollBarRealClickCoord) {\n      var scrollBarTopClick = scrollBarRealClickCoord - gridDimension.virtualPixelCell.fixedSize();\n      var scrollRatio = scrollBarTopClick / getMaxScrollBarCoord();\n      var scrollCoord = scrollRatio * pixelScrollDimension.maxScroll;\n      return scrollCoord;\n    }\n    function makeScrollBarDecorator() {\n      var decorator = grid.decorators.create();\n      decorator.fixed = true;\n      var viewPortClampFn = gridDimension.viewPort.clampPx;\n      decorator.postRender = function (scrollBarElem) {\n        scrollBarElem.setAttribute('class', 'grid-scroll-bar');\n        scrollBarElem.setAttribute('style', scrollBarElem.getAttribute('style') + \" border-radius: 6px;\\n                background: rgba(0, 0, 0, .5);\\n                z-index: 10;\");\n        decorator._onDragStart = function (e) {\n          if (e.target !== scrollBarElem) {\n            return;\n          }\n          var scrollBarOffset = gridDimension.cellMouse.layerPx(e);\n          decorator._unbindDrag = grid.eventLoop.bind('grid-drag', function (gridDragEvent) {\n            grid.eventLoop.stopBubbling(gridDragEvent);\n            var gridCoord = viewPortClampFn(gridDimension.cellMouse.gridPx(gridDragEvent));\n            var scrollBarRealClickCoord = gridCoord - scrollBarOffset;\n            var scrollCoord = getScrollPositionFromReal(scrollBarRealClickCoord);\n            pixelScrollDimension.scrollTo(scrollCoord);\n          });\n          decorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function () {\n            if (decorator._unbindDrag) {\n              decorator._unbindDrag();\n            }\n            if (decorator._unbindDragEnd) {\n              decorator._unbindDragEnd();\n            }\n          });\n          e.stopPropagation();\n        };\n        grid.eventLoop.bind(scrollBarElem, 'grid-drag-start', decorator._onDragStart);\n        grid.eventLoop.bind(scrollBarElem, 'mousedown', function (e) {\n          grid.eventLoop.stopBubbling(e);\n        });\n        return scrollBarElem;\n      };\n      decorator.units = 'px';\n      decorator.space = 'real';\n      gridCrossDimension.positionRange.setSize(decorator, scrollBarWidth);\n      return decorator;\n    }\n    var pixelScrollDimension = {\n      position: 0,\n      offset: 0,\n      maxScroll: 0,\n      scrollSize: 0,\n      maxIsAllTheWay: false,\n      scrollTo: function (px, dontNotify) {\n        pixelScrollDimension.position = util.clamp(px, 0, pixelScrollDimension.maxScroll);\n        pixelScrollDimension.positionScrollBar();\n        pixelScrollDimension.updatePixelOffset();\n        if (!dontNotify) {\n          notifyListeners();\n        }\n      },\n      updatePixelOffset: function () {\n        var modPixels = 0;\n        if (!grid.opts.snapToCell) {\n          var fixedSize = gridDimension.virtualPixelCell.fixedSize();\n          var rawCell = gridDimension.virtualPixelCell.toCellFromPx(pixelScrollDimension.position + fixedSize);\n          var cell = rawCell - gridDimension.rowColModel.numFixed();\n          var startCell = gridDimension.rowColModel.numFixed();\n          var endCell = cell + gridDimension.rowColModel.numFixed() - 1;\n          var position = gridDimension.virtualPixelCell.sizeOf(startCell, endCell);\n          modPixels = position - pixelScrollDimension.position;\n        }\n        if (pixelScrollDimension.offset !== modPixels) {\n          offsetDirtyClean.setDirty();\n        }\n        pixelScrollDimension.offset = modPixels;\n      },\n      scrollBar: makeScrollBarDecorator(),\n      positionScrollBar: function () {\n        gridDimension.positionRange.setPosition(pixelScrollDimension.scrollBar, getRealScrollBarPosition(pixelScrollDimension.position));\n      },\n      calcCellScrollPosition: function () {\n        var position = pixelScrollDimension.position;\n        var rawCell = gridDimension.virtualPixelCell.toCellFromPx(position + gridDimension.virtualPixelCell.fixedSize());\n        return rawCell - gridDimension.rowColModel.numFixed();\n      },\n      sizeScrollBar: function () {\n        gridCrossDimension.positionRange.setPosition(pixelScrollDimension.scrollBar, gridCrossDimension.viewPort.size - scrollBarWidth);\n        var scrollableViewSize = getViewScrollSize();\n        var scrollBarSize = Math.max(scrollableViewSize / gridDimension.virtualPixelCell.totalSize() * scrollableViewSize, 20);\n        gridDimension.positionRange.setSize(pixelScrollDimension.scrollBar, scrollBarSize);\n        if (scrollBarSize >= scrollableViewSize) {\n          gridDimension.positionRange.setSize(pixelScrollDimension.scrollBar, -1);\n        }\n      },\n      cacheMaxScroll: function () {\n        pixelScrollDimension.maxScroll = getMaxScroll();\n      },\n      cacheScrollSize: function () {\n        pixelScrollDimension.scrollSize = gridDimension.virtualPixelCell.totalSize() - gridDimension.virtualPixelCell.fixedSize();\n      },\n      _getMaxScroll: getMaxScroll\n    };\n    return pixelScrollDimension;\n  }\n  var dimensions = {\n    y: makeDimension(grid.rows, grid.cols),\n    x: makeDimension(grid.cols, grid.rows)\n  };\n  var model = {\n    get height() {\n      return dimensions.y.scrollSize;\n    },\n    get width() {\n      return dimensions.x.scrollSize;\n    },\n    get top() {\n      return dimensions.y.position;\n    },\n    get left() {\n      return dimensions.x.position;\n    },\n    get offsetTop() {\n      return dimensions.y.offset;\n    },\n    get offsetLeft() {\n      return dimensions.x.offset;\n    },\n    get vertScrollBar() {\n      return dimensions.y.scrollBar;\n    },\n    get horzScrollBar() {\n      return dimensions.x.scrollBar;\n    },\n    maxScroll: {\n      get height() {\n        return dimensions.y.scrollSize;\n      },\n      get width() {\n        return dimensions.x.scrollSize;\n      }\n    },\n    maxIsAllTheWayFor: {\n      get height() {\n        return dimensions.y.maxIsAllTheWay;\n      },\n      set height(h) {\n        dimensions.y.maxIsAllTheWay = h;\n      },\n      get width() {\n        return dimensions.x.maxIsAllTheWay;\n      },\n      set width(h) {\n        dimensions.x.maxIsAllTheWay = h;\n      }\n    },\n    isDirty: pixelDirtyClean.isDirty,\n    isOffsetDirty: offsetDirtyClean.isDirty,\n    setScrollSize: function (h, w) {\n      model.y.scrollSize = h;\n      model.x.scrollSize = w;\n    },\n    scrollTo: function (top, left, dontNotify) {\n      model.y.scrollTo(top, true);\n      model.x.scrollTo(left, true);\n      if (!dontNotify) {\n        notifyListeners();\n      }\n    },\n    _getMaxScroll: function (heightOrWidth) {\n      var dimension = heightOrWidth === 'height' ? model.y : model.x;\n      return dimension._getMaxScroll();\n    },\n    y: dimensions.y,\n    x: dimensions.x\n  };\n  grid.eventLoop.bind('grid-virtual-pixel-cell-change', function () {\n    model.y.cacheScrollSize();\n    model.x.cacheScrollSize();\n    cacheMaxScroll();\n    sizeScrollBars();\n    updatePixelOffsets();\n  });\n  grid.eventLoop.bind('grid-viewport-change', function () {\n    cacheMaxScroll();\n    sizeScrollBars();\n    updatePixelOffsets();\n  });\n  function cacheMaxScroll() {\n    model.y.cacheMaxScroll();\n    model.x.cacheMaxScroll();\n  }\n  function checkAngle(side1, side2) {\n    var angle = Math.abs(Math.atan(side1 / side2) * 57.29);\n    return angle < intentionAngle;\n  }\n  grid.eventLoop.bind('mousewheel', function (e) {\n    if (e.target !== grid.container && getScrollElementFromTarget(e.target, grid.container) !== grid.container) {\n      return;\n    }\n    var deltaY = e.deltaY;\n    var deltaX = e.deltaX;\n    if (checkAngle(deltaY, deltaX)) {\n      deltaY = 0;\n    } else if (checkAngle(deltaX, deltaY)) {\n      deltaX = 0;\n    }\n    model.scrollTo(model.top - deltaY, model.left - deltaX, false);\n    e.preventDefault();\n  });\n  function notifyListeners() {\n    grid.eventLoop.fire('grid-pixel-scroll');\n    grid.cellScrollModel.scrollTo(model.y.calcCellScrollPosition(), model.x.calcCellScrollPosition(), undefined, true);\n    pixelDirtyClean.setDirty();\n  }\n  function sizeScrollBars() {\n    model.y.sizeScrollBar();\n    model.x.sizeScrollBar();\n    positionScrollBars();\n  }\n  function positionScrollBars() {\n    model.y.positionScrollBar();\n    model.x.positionScrollBar();\n  }\n  function updatePixelOffsets() {\n    model.y.updatePixelOffset();\n    model.x.updatePixelOffset();\n  }\n  grid.decorators.add(model.y.scrollBar);\n  grid.decorators.add(model.x.scrollBar);\n  var hasStyle = function (elem) {\n    return !!elem.style;\n  };\n  function getScrollElementFromTarget(elem, stopParent) {\n    stopParent = stopParent || document;\n    if (!elem || !hasStyle(elem)) {\n      return stopParent;\n    }\n    var position = elem.style.position;\n    var excludeStaticParent = position === 'absolute';\n    var overflowRegex = /(auto|scroll)/;\n    var scrollParent = elem;\n    while (!!scrollParent && scrollParent !== stopParent) {\n      if (!(excludeStaticParent && scrollParent.style.position === 'static')) {\n        var computedStyle = getComputedStyle(scrollParent);\n        if (overflowRegex.test('' + computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n          break;\n        }\n      }\n      scrollParent = scrollParent.parentElement;\n    }\n    return position === 'fixed' || !scrollParent || scrollParent === elem ? elem.ownerDocument || stopParent : scrollParent;\n  }\n  return model;\n}\nexports.create = create;\nexports.default = create;","map":{"version":3,"names":["dirty_clean_1","require","util","create","grid","pixelDirtyClean","default","offsetDirtyClean","scrollBarWidth","intentionAngle","makeDimension","gridDimension","gridCrossDimension","getViewScrollSize","viewPort","size","virtualPixelCell","fixedSize","getScrollRatioFromVirtualScrollCoords","scroll","maxScroll","pixelScrollDimension","scrollRatio","getRealScrollBarPosition","maxScrollBarScroll","getMaxScrollBarCoord","scrollBarCoord","getMaxScroll","maxIsAllTheWay","Math","max","scrollSize","sizeOf","rowColModel","length","scrollLength","viewScrollSize","firstScrollableCell","numFixed","positionRange","getSize","scrollBar","getScrollPositionFromReal","scrollBarRealClickCoord","scrollBarTopClick","scrollCoord","makeScrollBarDecorator","decorator","decorators","fixed","viewPortClampFn","clampPx","postRender","scrollBarElem","setAttribute","getAttribute","_onDragStart","e","target","scrollBarOffset","cellMouse","layerPx","_unbindDrag","eventLoop","bind","gridDragEvent","stopBubbling","gridCoord","gridPx","scrollTo","_unbindDragEnd","stopPropagation","units","space","setSize","position","offset","px","dontNotify","clamp","positionScrollBar","updatePixelOffset","notifyListeners","modPixels","opts","snapToCell","rawCell","toCellFromPx","cell","startCell","endCell","setDirty","setPosition","calcCellScrollPosition","sizeScrollBar","scrollableViewSize","scrollBarSize","totalSize","cacheMaxScroll","cacheScrollSize","_getMaxScroll","dimensions","y","rows","cols","x","model","height","width","top","left","offsetTop","offsetLeft","vertScrollBar","horzScrollBar","maxIsAllTheWayFor","h","isDirty","isOffsetDirty","setScrollSize","w","heightOrWidth","dimension","sizeScrollBars","updatePixelOffsets","checkAngle","side1","side2","angle","abs","atan","container","getScrollElementFromTarget","deltaY","deltaX","preventDefault","fire","cellScrollModel","undefined","positionScrollBars","add","hasStyle","elem","style","stopParent","document","excludeStaticParent","overflowRegex","scrollParent","computedStyle","getComputedStyle","test","overflow","overflowY","overflowX","parentElement","ownerDocument","exports"],"sources":["C:\\amazon\\amazon\\node_modules\\grid\\src\\modules\\pixel-scroll-model\\index.ts"],"sourcesContent":["import { Grid, IGridDimension } from '../core';\nimport { IDecorator } from '../decorators';\nimport makeDirtyClean from '../dirty-clean';\nimport { IGridCustomMouseEvent } from '../event-loop';\nimport * as util from '../util';\n\nexport interface IPixelScrollModel {\n  x: IPixelScrollDimensionInfo;\n  y: IPixelScrollDimensionInfo;\n  top: number;\n  left: number;\n  height: number;\n  width: number;\n  offsetTop: number;\n  offsetLeft: number;\n  vertScrollBar: IScrollBarDecorator;\n  horzScrollBar: IScrollBarDecorator;\n  maxScroll: {\n    height?: number,\n    width?: number\n  };\n  maxIsAllTheWayFor: {\n    height: boolean,\n    width: boolean\n  };\n  isDirty(): boolean;\n  isOffsetDirty(): boolean;\n  scrollTo(x: number, y: number, dontNotify?: boolean): void;\n  setScrollSize(h: number, w: number): void;\n  _getMaxScroll(heightOrWidth: 'height' | 'width'): number;\n}\n\nexport interface IScrollBarDecorator extends IDecorator {\n  _onDragStart?(e: IGridCustomMouseEvent): void;\n  _unbindDrag?(): void;\n  _unbindDragEnd?(): void;\n}\n\nexport interface IPixelScrollDimensionInfo {\n  position: number;\n  offset: number;\n  scrollSize: number;\n  maxScroll: number;\n  maxIsAllTheWay: boolean;\n  scrollBar: IScrollBarDecorator;\n  scrollTo(px: number, dontNotify?: boolean): void;\n  positionScrollBar(): void;\n  updatePixelOffset(): void;\n  calcCellScrollPosition(): number;\n  sizeScrollBar(): void;\n  cacheMaxScroll(): void;\n  cacheScrollSize(): void;\n  _getMaxScroll(): number;\n}\n\nexport function create(grid: Grid) {\n  const pixelDirtyClean = makeDirtyClean(grid);\n  const offsetDirtyClean = makeDirtyClean(grid);\n  const scrollBarWidth = 10;\n  const intentionAngle = 30;\n\n  function makeDimension(\n    gridDimension: IGridDimension,\n    gridCrossDimension: IGridDimension,\n  ) {\n\n    function getViewScrollSize() {\n      return gridDimension.viewPort.size - gridDimension.virtualPixelCell.fixedSize();\n    }\n\n    function getScrollRatioFromVirtualScrollCoords(scroll: number) {\n      const maxScroll = pixelScrollDimension.maxScroll;\n      const scrollRatio = scroll / maxScroll;\n      return scrollRatio;\n    }\n\n    function getRealScrollBarPosition(scroll: number) {\n      const scrollRatio = getScrollRatioFromVirtualScrollCoords(scroll);\n      const maxScrollBarScroll = getMaxScrollBarCoord();\n      // in scroll bar coords\n      const scrollBarCoord = scrollRatio * maxScrollBarScroll;\n      // add the fixed height to translate back into real coords\n      return scrollBarCoord + gridDimension.virtualPixelCell.fixedSize();\n    }\n\n    function getMaxScroll() {\n      if (pixelScrollDimension.maxIsAllTheWay) {\n        return Math.max(\n          0,\n          pixelScrollDimension.scrollSize - gridDimension.virtualPixelCell.sizeOf(gridDimension.rowColModel.length(true) - 1)\n        );\n      }\n\n      let scrollLength = pixelScrollDimension.scrollSize;\n      const viewScrollSize = getViewScrollSize();\n\n      if (scrollLength <= viewScrollSize) {\n        return 0;\n      }\n\n      let firstScrollableCell = gridDimension.rowColModel.numFixed();\n      while (scrollLength > viewScrollSize - 10 && firstScrollableCell < gridDimension.rowColModel.length(true)) {\n        scrollLength -= gridDimension.virtualPixelCell.sizeOf(firstScrollableCell);\n        firstScrollableCell++;\n      }\n      return pixelScrollDimension.scrollSize - scrollLength;\n    }\n\n    function getMaxScrollBarCoord() {\n      return getViewScrollSize() - (gridDimension.positionRange.getSize(pixelScrollDimension.scrollBar) || scrollBarWidth);\n    }\n\n    function getScrollPositionFromReal(scrollBarRealClickCoord: number) {\n      const scrollBarTopClick = scrollBarRealClickCoord - gridDimension.virtualPixelCell.fixedSize();\n      const scrollRatio = scrollBarTopClick / getMaxScrollBarCoord();\n      const scrollCoord = scrollRatio * pixelScrollDimension.maxScroll;\n      return scrollCoord;\n    }\n\n    function makeScrollBarDecorator() {\n      const decorator: IScrollBarDecorator = grid.decorators.create();\n      decorator.fixed = true;\n      const viewPortClampFn = gridDimension.viewPort.clampPx;\n\n      decorator.postRender = (scrollBarElem: HTMLElement) => {\n        scrollBarElem.setAttribute('class', 'grid-scroll-bar');\n        scrollBarElem.setAttribute('style', `${scrollBarElem.getAttribute('style')} border-radius: 6px;\n                background: rgba(0, 0, 0, .5);\n                z-index: 10;`);\n        decorator._onDragStart = (e) => {\n          if (e.target !== scrollBarElem) {\n            return;\n          }\n          const scrollBarOffset = gridDimension.cellMouse.layerPx(e);\n\n          decorator._unbindDrag = grid.eventLoop.bind('grid-drag', (gridDragEvent: IGridCustomMouseEvent) => {\n            grid.eventLoop.stopBubbling(gridDragEvent);\n            const gridCoord = viewPortClampFn(gridDimension.cellMouse.gridPx(gridDragEvent));\n            const scrollBarRealClickCoord = gridCoord - scrollBarOffset;\n            const scrollCoord = getScrollPositionFromReal(scrollBarRealClickCoord);\n            pixelScrollDimension.scrollTo(scrollCoord);\n          });\n\n          decorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', () => {\n            if (decorator._unbindDrag) {\n              decorator._unbindDrag();\n            }\n            if (decorator._unbindDragEnd) {\n              decorator._unbindDragEnd();\n            }\n          });\n\n          e.stopPropagation();\n        };\n\n        grid.eventLoop.bind(scrollBarElem, 'grid-drag-start', decorator._onDragStart);\n        grid.eventLoop.bind(scrollBarElem, 'mousedown', (e) => {\n          grid.eventLoop.stopBubbling(e);\n        });\n\n        return scrollBarElem;\n      };\n\n      decorator.units = 'px';\n      decorator.space = 'real';\n      gridCrossDimension.positionRange.setSize(decorator, scrollBarWidth);\n      return decorator;\n    }\n\n    const pixelScrollDimension: IPixelScrollDimensionInfo = {\n      position: 0,\n      offset: 0,\n      maxScroll: 0,\n      scrollSize: 0,\n      maxIsAllTheWay: false,\n      scrollTo(px: number, dontNotify?: boolean) {\n        pixelScrollDimension.position = util.clamp(px, 0, pixelScrollDimension.maxScroll);\n        pixelScrollDimension.positionScrollBar();\n        pixelScrollDimension.updatePixelOffset();\n\n        if (!dontNotify) {\n          notifyListeners();\n        }\n      },\n      updatePixelOffset() {\n        let modPixels = 0;\n        if (!grid.opts.snapToCell) {\n          const fixedSize = gridDimension.virtualPixelCell.fixedSize();\n          const rawCell = gridDimension.virtualPixelCell.toCellFromPx(pixelScrollDimension.position + fixedSize);\n          const cell = rawCell - gridDimension.rowColModel.numFixed();\n          const startCell = gridDimension.rowColModel.numFixed();\n          const endCell = cell + gridDimension.rowColModel.numFixed() - 1;\n          const position = gridDimension.virtualPixelCell.sizeOf(startCell, endCell);\n          modPixels = position - pixelScrollDimension.position;\n        }\n        if (pixelScrollDimension.offset !== modPixels) {\n          offsetDirtyClean.setDirty();\n        }\n        pixelScrollDimension.offset = modPixels;\n      },\n      scrollBar: makeScrollBarDecorator(),\n      positionScrollBar() {\n        gridDimension.positionRange.setPosition(\n          pixelScrollDimension.scrollBar,\n          getRealScrollBarPosition(pixelScrollDimension.position)\n        );\n      },\n      calcCellScrollPosition() {\n        const position = pixelScrollDimension.position;\n        const rawCell = gridDimension.virtualPixelCell.toCellFromPx(\n          position + gridDimension.virtualPixelCell.fixedSize()\n        );\n        return rawCell - gridDimension.rowColModel.numFixed();\n      },\n      sizeScrollBar() {\n\n        // viewport.size needs to be cross size\n        gridCrossDimension.positionRange.setPosition(\n          pixelScrollDimension.scrollBar,\n          gridCrossDimension.viewPort.size - scrollBarWidth\n        );\n        const scrollableViewSize = getViewScrollSize();\n        const scrollBarSize = Math.max(scrollableViewSize / gridDimension.virtualPixelCell.totalSize() * scrollableViewSize, 20);\n        gridDimension.positionRange.setSize(\n          pixelScrollDimension.scrollBar,\n          scrollBarSize\n        );\n        if (scrollBarSize >= scrollableViewSize) {\n          gridDimension.positionRange.setSize(\n            pixelScrollDimension.scrollBar,\n            -1\n          );\n        }\n      },\n      cacheMaxScroll() {\n        pixelScrollDimension.maxScroll = getMaxScroll();\n      },\n      cacheScrollSize() {\n        pixelScrollDimension.scrollSize = gridDimension.virtualPixelCell.totalSize() - gridDimension.virtualPixelCell.fixedSize();\n      },\n      _getMaxScroll: getMaxScroll\n    };\n    return pixelScrollDimension;\n  }\n\n  const dimensions = {\n    y: makeDimension(grid.rows, grid.cols),\n    x: makeDimension(grid.cols, grid.rows),\n  };\n  const model: IPixelScrollModel = {\n    get height() {\n      return dimensions.y.scrollSize;\n    },\n    get width() {\n      return dimensions.x.scrollSize;\n    },\n    get top() {\n      return dimensions.y.position;\n    },\n    get left() {\n      return dimensions.x.position;\n    },\n    get offsetTop() {\n      return dimensions.y.offset;\n    },\n    get offsetLeft() {\n      return dimensions.x.offset;\n    },\n    get vertScrollBar() {\n      return dimensions.y.scrollBar;\n    },\n    get horzScrollBar() {\n      return dimensions.x.scrollBar;\n    },\n    maxScroll: {\n      get height() {\n        return dimensions.y.scrollSize;\n      },\n      get width() {\n        return dimensions.x.scrollSize;\n      }\n    },\n    maxIsAllTheWayFor: {\n      get height() {\n        return dimensions.y.maxIsAllTheWay;\n      },\n      set height(h: boolean) {\n        dimensions.y.maxIsAllTheWay = h;\n      },\n      get width() {\n        return dimensions.x.maxIsAllTheWay;\n      },\n      set width(h: boolean) {\n        dimensions.x.maxIsAllTheWay = h;\n      },\n    },\n    isDirty: pixelDirtyClean.isDirty,\n    isOffsetDirty: offsetDirtyClean.isDirty,\n    setScrollSize(h: number, w: number) {\n      model.y.scrollSize = h;\n      model.x.scrollSize = w;\n    },\n    scrollTo(top: number, left: number, dontNotify?: boolean) {\n      model.y.scrollTo(top, true);\n      model.x.scrollTo(left, true);\n      if (!dontNotify) {\n        notifyListeners();\n      }\n\n    },\n    _getMaxScroll(heightOrWidth: 'height' | 'width') {\n      const dimension = heightOrWidth === 'height' ? model.y : model.x;\n      return dimension._getMaxScroll();\n    },\n    y: dimensions.y,\n    x: dimensions.x,\n  };\n\n  grid.eventLoop.bind('grid-virtual-pixel-cell-change', () => {\n    model.y.cacheScrollSize();\n    model.x.cacheScrollSize();\n    cacheMaxScroll();\n    sizeScrollBars();\n    updatePixelOffsets();\n  });\n\n  grid.eventLoop.bind('grid-viewport-change', () => {\n    cacheMaxScroll();\n    sizeScrollBars();\n    updatePixelOffsets();\n  });\n\n  function cacheMaxScroll() {\n    model.y.cacheMaxScroll();\n    model.x.cacheMaxScroll();\n  }\n\n  function checkAngle(side1: number, side2: number) {\n    const angle = Math.abs(Math.atan(side1 / side2) * 57.29);\n    return angle < intentionAngle;\n  }\n\n  // assumes a standardized wheel event that we create through the mousewheel package\n  grid.eventLoop.bind('mousewheel', (e: MouseWheelEvent) => {\n    if (e.target !== grid.container && getScrollElementFromTarget(e.target, grid.container) !== grid.container) {\n      return;\n    }\n\n    let deltaY = e.deltaY;\n    let deltaX = e.deltaX;\n    if (checkAngle(deltaY, deltaX)) {\n      deltaY = 0;\n    } else if (checkAngle(deltaX, deltaY)) {\n      deltaX = 0;\n    }\n\n    model.scrollTo(model.top - deltaY, model.left - deltaX, false);\n    e.preventDefault();\n  });\n\n  function notifyListeners() {\n    // TODO: possibly keep track of delta since last update and send it along. for now, no\n    grid.eventLoop.fire('grid-pixel-scroll');\n\n    // update the cell scroll\n    grid.cellScrollModel.scrollTo(model.y.calcCellScrollPosition(), model.x.calcCellScrollPosition(), undefined, true);\n    pixelDirtyClean.setDirty();\n  }\n\n  /* SCROLL BAR LOGIC */\n\n  function sizeScrollBars() {\n    model.y.sizeScrollBar();\n    model.x.sizeScrollBar();\n    positionScrollBars();\n  }\n\n  function positionScrollBars() {\n    model.y.positionScrollBar();\n    model.x.positionScrollBar();\n  }\n\n  function updatePixelOffsets() {\n    model.y.updatePixelOffset();\n    model.x.updatePixelOffset();\n  }\n\n  grid.decorators.add(model.y.scrollBar);\n  grid.decorators.add(model.x.scrollBar);\n  /* END SCROLL BAR LOGIC */\n\n  const hasStyle = (elem: EventTarget): elem is HTMLElement => !!(elem as any).style;\n\n  function getScrollElementFromTarget(elem: EventTarget | null, stopParent?: HTMLElement | Document) {\n    stopParent = stopParent || document;\n    if (!elem || !(hasStyle(elem))) {\n      return stopParent;\n    }\n\n    const position = elem.style.position;\n    const excludeStaticParent = position === 'absolute';\n    const overflowRegex = /(auto|scroll)/;\n    let scrollParent: HTMLElement | null = elem;\n\n    while (!!scrollParent && scrollParent !== stopParent) {\n      if (!(excludeStaticParent && scrollParent.style.position === 'static')) {\n        const computedStyle = getComputedStyle(scrollParent);\n\n        if (overflowRegex.test('' + computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n          break;\n        }\n      }\n\n      scrollParent = scrollParent.parentElement;\n    }\n\n    return position === 'fixed' || !scrollParent || scrollParent === elem ? elem.ownerDocument || stopParent : scrollParent;\n  }\n\n  return model;\n}\n\nexport default create;"],"mappings":";;;;;;AAEA,IAAAA,aAAA,GAAAC,OAAA;AAEA,IAAAC,IAAA,GAAAD,OAAA;AAmDA,SAAgBE,MAAMA,CAACC,IAAU;EAC/B,IAAMC,eAAe,GAAGL,aAAA,CAAAM,OAAc,CAACF,IAAI,CAAC;EAC5C,IAAMG,gBAAgB,GAAGP,aAAA,CAAAM,OAAc,CAACF,IAAI,CAAC;EAC7C,IAAMI,cAAc,GAAG,EAAE;EACzB,IAAMC,cAAc,GAAG,EAAE;EAEzB,SAASC,aAAaA,CACpBC,aAA6B,EAC7BC,kBAAkC;IAGlC,SAASC,iBAAiBA,CAAA;MACxB,OAAOF,aAAa,CAACG,QAAQ,CAACC,IAAI,GAAGJ,aAAa,CAACK,gBAAgB,CAACC,SAAS,EAAE;IACjF;IAEA,SAASC,qCAAqCA,CAACC,MAAc;MAC3D,IAAMC,SAAS,GAAGC,oBAAoB,CAACD,SAAS;MAChD,IAAME,WAAW,GAAGH,MAAM,GAAGC,SAAS;MACtC,OAAOE,WAAW;IACpB;IAEA,SAASC,wBAAwBA,CAACJ,MAAc;MAC9C,IAAMG,WAAW,GAAGJ,qCAAqC,CAACC,MAAM,CAAC;MACjE,IAAMK,kBAAkB,GAAGC,oBAAoB,EAAE;MAEjD,IAAMC,cAAc,GAAGJ,WAAW,GAAGE,kBAAkB;MAEvD,OAAOE,cAAc,GAAGf,aAAa,CAACK,gBAAgB,CAACC,SAAS,EAAE;IACpE;IAEA,SAASU,YAAYA,CAAA;MACnB,IAAIN,oBAAoB,CAACO,cAAc,EAAE;QACvC,OAAOC,IAAI,CAACC,GAAG,CACb,CAAC,EACDT,oBAAoB,CAACU,UAAU,GAAGpB,aAAa,CAACK,gBAAgB,CAACgB,MAAM,CAACrB,aAAa,CAACsB,WAAW,CAACC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CACpH;;MAGH,IAAIC,YAAY,GAAGd,oBAAoB,CAACU,UAAU;MAClD,IAAMK,cAAc,GAAGvB,iBAAiB,EAAE;MAE1C,IAAIsB,YAAY,IAAIC,cAAc,EAAE;QAClC,OAAO,CAAC;;MAGV,IAAIC,mBAAmB,GAAG1B,aAAa,CAACsB,WAAW,CAACK,QAAQ,EAAE;MAC9D,OAAOH,YAAY,GAAGC,cAAc,GAAG,EAAE,IAAIC,mBAAmB,GAAG1B,aAAa,CAACsB,WAAW,CAACC,MAAM,CAAC,IAAI,CAAC,EAAE;QACzGC,YAAY,IAAIxB,aAAa,CAACK,gBAAgB,CAACgB,MAAM,CAACK,mBAAmB,CAAC;QAC1EA,mBAAmB,EAAE;;MAEvB,OAAOhB,oBAAoB,CAACU,UAAU,GAAGI,YAAY;IACvD;IAEA,SAASV,oBAAoBA,CAAA;MAC3B,OAAOZ,iBAAiB,EAAE,IAAIF,aAAa,CAAC4B,aAAa,CAACC,OAAO,CAACnB,oBAAoB,CAACoB,SAAS,CAAC,IAAIjC,cAAc,CAAC;IACtH;IAEA,SAASkC,yBAAyBA,CAACC,uBAA+B;MAChE,IAAMC,iBAAiB,GAAGD,uBAAuB,GAAGhC,aAAa,CAACK,gBAAgB,CAACC,SAAS,EAAE;MAC9F,IAAMK,WAAW,GAAGsB,iBAAiB,GAAGnB,oBAAoB,EAAE;MAC9D,IAAMoB,WAAW,GAAGvB,WAAW,GAAGD,oBAAoB,CAACD,SAAS;MAChE,OAAOyB,WAAW;IACpB;IAEA,SAASC,sBAAsBA,CAAA;MAC7B,IAAMC,SAAS,GAAwB3C,IAAI,CAAC4C,UAAU,CAAC7C,MAAM,EAAE;MAC/D4C,SAAS,CAACE,KAAK,GAAG,IAAI;MACtB,IAAMC,eAAe,GAAGvC,aAAa,CAACG,QAAQ,CAACqC,OAAO;MAEtDJ,SAAS,CAACK,UAAU,GAAG,UAACC,aAA0B;QAChDA,aAAa,CAACC,YAAY,CAAC,OAAO,EAAE,iBAAiB,CAAC;QACtDD,aAAa,CAACC,YAAY,CAAC,OAAO,EAAKD,aAAa,CAACE,YAAY,CAAC,OAAO,CAAC,uGAErD,CAAC;QACtBR,SAAS,CAACS,YAAY,GAAG,UAACC,CAAC;UACzB,IAAIA,CAAC,CAACC,MAAM,KAAKL,aAAa,EAAE;YAC9B;;UAEF,IAAMM,eAAe,GAAGhD,aAAa,CAACiD,SAAS,CAACC,OAAO,CAACJ,CAAC,CAAC;UAE1DV,SAAS,CAACe,WAAW,GAAG1D,IAAI,CAAC2D,SAAS,CAACC,IAAI,CAAC,WAAW,EAAE,UAACC,aAAoC;YAC5F7D,IAAI,CAAC2D,SAAS,CAACG,YAAY,CAACD,aAAa,CAAC;YAC1C,IAAME,SAAS,GAAGjB,eAAe,CAACvC,aAAa,CAACiD,SAAS,CAACQ,MAAM,CAACH,aAAa,CAAC,CAAC;YAChF,IAAMtB,uBAAuB,GAAGwB,SAAS,GAAGR,eAAe;YAC3D,IAAMd,WAAW,GAAGH,yBAAyB,CAACC,uBAAuB,CAAC;YACtEtB,oBAAoB,CAACgD,QAAQ,CAACxB,WAAW,CAAC;UAC5C,CAAC,CAAC;UAEFE,SAAS,CAACuB,cAAc,GAAGlE,IAAI,CAAC2D,SAAS,CAACC,IAAI,CAAC,eAAe,EAAE;YAC9D,IAAIjB,SAAS,CAACe,WAAW,EAAE;cACzBf,SAAS,CAACe,WAAW,EAAE;;YAEzB,IAAIf,SAAS,CAACuB,cAAc,EAAE;cAC5BvB,SAAS,CAACuB,cAAc,EAAE;;UAE9B,CAAC,CAAC;UAEFb,CAAC,CAACc,eAAe,EAAE;QACrB,CAAC;QAEDnE,IAAI,CAAC2D,SAAS,CAACC,IAAI,CAACX,aAAa,EAAE,iBAAiB,EAAEN,SAAS,CAACS,YAAY,CAAC;QAC7EpD,IAAI,CAAC2D,SAAS,CAACC,IAAI,CAACX,aAAa,EAAE,WAAW,EAAE,UAACI,CAAC;UAChDrD,IAAI,CAAC2D,SAAS,CAACG,YAAY,CAACT,CAAC,CAAC;QAChC,CAAC,CAAC;QAEF,OAAOJ,aAAa;MACtB,CAAC;MAEDN,SAAS,CAACyB,KAAK,GAAG,IAAI;MACtBzB,SAAS,CAAC0B,KAAK,GAAG,MAAM;MACxB7D,kBAAkB,CAAC2B,aAAa,CAACmC,OAAO,CAAC3B,SAAS,EAAEvC,cAAc,CAAC;MACnE,OAAOuC,SAAS;IAClB;IAEA,IAAM1B,oBAAoB,GAA8B;MACtDsD,QAAQ,EAAE,CAAC;MACXC,MAAM,EAAE,CAAC;MACTxD,SAAS,EAAE,CAAC;MACZW,UAAU,EAAE,CAAC;MACbH,cAAc,EAAE,KAAK;MACrByC,QAAQ,EAAR,SAAAA,CAASQ,EAAU,EAAEC,UAAoB;QACvCzD,oBAAoB,CAACsD,QAAQ,GAAGzE,IAAI,CAAC6E,KAAK,CAACF,EAAE,EAAE,CAAC,EAAExD,oBAAoB,CAACD,SAAS,CAAC;QACjFC,oBAAoB,CAAC2D,iBAAiB,EAAE;QACxC3D,oBAAoB,CAAC4D,iBAAiB,EAAE;QAExC,IAAI,CAACH,UAAU,EAAE;UACfI,eAAe,EAAE;;MAErB,CAAC;MACDD,iBAAiB,WAAAA,CAAA;QACf,IAAIE,SAAS,GAAG,CAAC;QACjB,IAAI,CAAC/E,IAAI,CAACgF,IAAI,CAACC,UAAU,EAAE;UACzB,IAAMpE,SAAS,GAAGN,aAAa,CAACK,gBAAgB,CAACC,SAAS,EAAE;UAC5D,IAAMqE,OAAO,GAAG3E,aAAa,CAACK,gBAAgB,CAACuE,YAAY,CAAClE,oBAAoB,CAACsD,QAAQ,GAAG1D,SAAS,CAAC;UACtG,IAAMuE,IAAI,GAAGF,OAAO,GAAG3E,aAAa,CAACsB,WAAW,CAACK,QAAQ,EAAE;UAC3D,IAAMmD,SAAS,GAAG9E,aAAa,CAACsB,WAAW,CAACK,QAAQ,EAAE;UACtD,IAAMoD,OAAO,GAAGF,IAAI,GAAG7E,aAAa,CAACsB,WAAW,CAACK,QAAQ,EAAE,GAAG,CAAC;UAC/D,IAAMqC,QAAQ,GAAGhE,aAAa,CAACK,gBAAgB,CAACgB,MAAM,CAACyD,SAAS,EAAEC,OAAO,CAAC;UAC1EP,SAAS,GAAGR,QAAQ,GAAGtD,oBAAoB,CAACsD,QAAQ;;QAEtD,IAAItD,oBAAoB,CAACuD,MAAM,KAAKO,SAAS,EAAE;UAC7C5E,gBAAgB,CAACoF,QAAQ,EAAE;;QAE7BtE,oBAAoB,CAACuD,MAAM,GAAGO,SAAS;MACzC,CAAC;MACD1C,SAAS,EAAEK,sBAAsB,EAAE;MACnCkC,iBAAiB,WAAAA,CAAA;QACfrE,aAAa,CAAC4B,aAAa,CAACqD,WAAW,CACrCvE,oBAAoB,CAACoB,SAAS,EAC9BlB,wBAAwB,CAACF,oBAAoB,CAACsD,QAAQ,CAAC,CACxD;MACH,CAAC;MACDkB,sBAAsB,WAAAA,CAAA;QACpB,IAAMlB,QAAQ,GAAGtD,oBAAoB,CAACsD,QAAQ;QAC9C,IAAMW,OAAO,GAAG3E,aAAa,CAACK,gBAAgB,CAACuE,YAAY,CACzDZ,QAAQ,GAAGhE,aAAa,CAACK,gBAAgB,CAACC,SAAS,EAAE,CACtD;QACD,OAAOqE,OAAO,GAAG3E,aAAa,CAACsB,WAAW,CAACK,QAAQ,EAAE;MACvD,CAAC;MACDwD,aAAa,WAAAA,CAAA;QAGXlF,kBAAkB,CAAC2B,aAAa,CAACqD,WAAW,CAC1CvE,oBAAoB,CAACoB,SAAS,EAC9B7B,kBAAkB,CAACE,QAAQ,CAACC,IAAI,GAAGP,cAAc,CAClD;QACD,IAAMuF,kBAAkB,GAAGlF,iBAAiB,EAAE;QAC9C,IAAMmF,aAAa,GAAGnE,IAAI,CAACC,GAAG,CAACiE,kBAAkB,GAAGpF,aAAa,CAACK,gBAAgB,CAACiF,SAAS,EAAE,GAAGF,kBAAkB,EAAE,EAAE,CAAC;QACxHpF,aAAa,CAAC4B,aAAa,CAACmC,OAAO,CACjCrD,oBAAoB,CAACoB,SAAS,EAC9BuD,aAAa,CACd;QACD,IAAIA,aAAa,IAAID,kBAAkB,EAAE;UACvCpF,aAAa,CAAC4B,aAAa,CAACmC,OAAO,CACjCrD,oBAAoB,CAACoB,SAAS,EAC9B,CAAC,CAAC,CACH;;MAEL,CAAC;MACDyD,cAAc,WAAAA,CAAA;QACZ7E,oBAAoB,CAACD,SAAS,GAAGO,YAAY,EAAE;MACjD,CAAC;MACDwE,eAAe,WAAAA,CAAA;QACb9E,oBAAoB,CAACU,UAAU,GAAGpB,aAAa,CAACK,gBAAgB,CAACiF,SAAS,EAAE,GAAGtF,aAAa,CAACK,gBAAgB,CAACC,SAAS,EAAE;MAC3H,CAAC;MACDmF,aAAa,EAAEzE;KAChB;IACD,OAAON,oBAAoB;EAC7B;EAEA,IAAMgF,UAAU,GAAG;IACjBC,CAAC,EAAE5F,aAAa,CAACN,IAAI,CAACmG,IAAI,EAAEnG,IAAI,CAACoG,IAAI,CAAC;IACtCC,CAAC,EAAE/F,aAAa,CAACN,IAAI,CAACoG,IAAI,EAAEpG,IAAI,CAACmG,IAAI;GACtC;EACD,IAAMG,KAAK,GAAsB;IAC/B,IAAIC,MAAMA,CAAA;MACR,OAAON,UAAU,CAACC,CAAC,CAACvE,UAAU;IAChC,CAAC;IACD,IAAI6E,KAAKA,CAAA;MACP,OAAOP,UAAU,CAACI,CAAC,CAAC1E,UAAU;IAChC,CAAC;IACD,IAAI8E,GAAGA,CAAA;MACL,OAAOR,UAAU,CAACC,CAAC,CAAC3B,QAAQ;IAC9B,CAAC;IACD,IAAImC,IAAIA,CAAA;MACN,OAAOT,UAAU,CAACI,CAAC,CAAC9B,QAAQ;IAC9B,CAAC;IACD,IAAIoC,SAASA,CAAA;MACX,OAAOV,UAAU,CAACC,CAAC,CAAC1B,MAAM;IAC5B,CAAC;IACD,IAAIoC,UAAUA,CAAA;MACZ,OAAOX,UAAU,CAACI,CAAC,CAAC7B,MAAM;IAC5B,CAAC;IACD,IAAIqC,aAAaA,CAAA;MACf,OAAOZ,UAAU,CAACC,CAAC,CAAC7D,SAAS;IAC/B,CAAC;IACD,IAAIyE,aAAaA,CAAA;MACf,OAAOb,UAAU,CAACI,CAAC,CAAChE,SAAS;IAC/B,CAAC;IACDrB,SAAS,EAAE;MACT,IAAIuF,MAAMA,CAAA;QACR,OAAON,UAAU,CAACC,CAAC,CAACvE,UAAU;MAChC,CAAC;MACD,IAAI6E,KAAKA,CAAA;QACP,OAAOP,UAAU,CAACI,CAAC,CAAC1E,UAAU;MAChC;KACD;IACDoF,iBAAiB,EAAE;MACjB,IAAIR,MAAMA,CAAA;QACR,OAAON,UAAU,CAACC,CAAC,CAAC1E,cAAc;MACpC,CAAC;MACD,IAAI+E,MAAMA,CAACS,CAAU;QACnBf,UAAU,CAACC,CAAC,CAAC1E,cAAc,GAAGwF,CAAC;MACjC,CAAC;MACD,IAAIR,KAAKA,CAAA;QACP,OAAOP,UAAU,CAACI,CAAC,CAAC7E,cAAc;MACpC,CAAC;MACD,IAAIgF,KAAKA,CAACQ,CAAU;QAClBf,UAAU,CAACI,CAAC,CAAC7E,cAAc,GAAGwF,CAAC;MACjC;KACD;IACDC,OAAO,EAAEhH,eAAe,CAACgH,OAAO;IAChCC,aAAa,EAAE/G,gBAAgB,CAAC8G,OAAO;IACvCE,aAAa,EAAb,SAAAA,CAAcH,CAAS,EAAEI,CAAS;MAChCd,KAAK,CAACJ,CAAC,CAACvE,UAAU,GAAGqF,CAAC;MACtBV,KAAK,CAACD,CAAC,CAAC1E,UAAU,GAAGyF,CAAC;IACxB,CAAC;IACDnD,QAAQ,EAAR,SAAAA,CAASwC,GAAW,EAAEC,IAAY,EAAEhC,UAAoB;MACtD4B,KAAK,CAACJ,CAAC,CAACjC,QAAQ,CAACwC,GAAG,EAAE,IAAI,CAAC;MAC3BH,KAAK,CAACD,CAAC,CAACpC,QAAQ,CAACyC,IAAI,EAAE,IAAI,CAAC;MAC5B,IAAI,CAAChC,UAAU,EAAE;QACfI,eAAe,EAAE;;IAGrB,CAAC;IACDkB,aAAa,EAAb,SAAAA,CAAcqB,aAAiC;MAC7C,IAAMC,SAAS,GAAGD,aAAa,KAAK,QAAQ,GAAGf,KAAK,CAACJ,CAAC,GAAGI,KAAK,CAACD,CAAC;MAChE,OAAOiB,SAAS,CAACtB,aAAa,EAAE;IAClC,CAAC;IACDE,CAAC,EAAED,UAAU,CAACC,CAAC;IACfG,CAAC,EAAEJ,UAAU,CAACI;GACf;EAEDrG,IAAI,CAAC2D,SAAS,CAACC,IAAI,CAAC,gCAAgC,EAAE;IACpD0C,KAAK,CAACJ,CAAC,CAACH,eAAe,EAAE;IACzBO,KAAK,CAACD,CAAC,CAACN,eAAe,EAAE;IACzBD,cAAc,EAAE;IAChByB,cAAc,EAAE;IAChBC,kBAAkB,EAAE;EACtB,CAAC,CAAC;EAEFxH,IAAI,CAAC2D,SAAS,CAACC,IAAI,CAAC,sBAAsB,EAAE;IAC1CkC,cAAc,EAAE;IAChByB,cAAc,EAAE;IAChBC,kBAAkB,EAAE;EACtB,CAAC,CAAC;EAEF,SAAS1B,cAAcA,CAAA;IACrBQ,KAAK,CAACJ,CAAC,CAACJ,cAAc,EAAE;IACxBQ,KAAK,CAACD,CAAC,CAACP,cAAc,EAAE;EAC1B;EAEA,SAAS2B,UAAUA,CAACC,KAAa,EAAEC,KAAa;IAC9C,IAAMC,KAAK,GAAGnG,IAAI,CAACoG,GAAG,CAACpG,IAAI,CAACqG,IAAI,CAACJ,KAAK,GAAGC,KAAK,CAAC,GAAG,KAAK,CAAC;IACxD,OAAOC,KAAK,GAAGvH,cAAc;EAC/B;EAGAL,IAAI,CAAC2D,SAAS,CAACC,IAAI,CAAC,YAAY,EAAE,UAACP,CAAkB;IACnD,IAAIA,CAAC,CAACC,MAAM,KAAKtD,IAAI,CAAC+H,SAAS,IAAIC,0BAA0B,CAAC3E,CAAC,CAACC,MAAM,EAAEtD,IAAI,CAAC+H,SAAS,CAAC,KAAK/H,IAAI,CAAC+H,SAAS,EAAE;MAC1G;;IAGF,IAAIE,MAAM,GAAG5E,CAAC,CAAC4E,MAAM;IACrB,IAAIC,MAAM,GAAG7E,CAAC,CAAC6E,MAAM;IACrB,IAAIT,UAAU,CAACQ,MAAM,EAAEC,MAAM,CAAC,EAAE;MAC9BD,MAAM,GAAG,CAAC;KACX,MAAM,IAAIR,UAAU,CAACS,MAAM,EAAED,MAAM,CAAC,EAAE;MACrCC,MAAM,GAAG,CAAC;;IAGZ5B,KAAK,CAACrC,QAAQ,CAACqC,KAAK,CAACG,GAAG,GAAGwB,MAAM,EAAE3B,KAAK,CAACI,IAAI,GAAGwB,MAAM,EAAE,KAAK,CAAC;IAC9D7E,CAAC,CAAC8E,cAAc,EAAE;EACpB,CAAC,CAAC;EAEF,SAASrD,eAAeA,CAAA;IAEtB9E,IAAI,CAAC2D,SAAS,CAACyE,IAAI,CAAC,mBAAmB,CAAC;IAGxCpI,IAAI,CAACqI,eAAe,CAACpE,QAAQ,CAACqC,KAAK,CAACJ,CAAC,CAACT,sBAAsB,EAAE,EAAEa,KAAK,CAACD,CAAC,CAACZ,sBAAsB,EAAE,EAAE6C,SAAS,EAAE,IAAI,CAAC;IAClHrI,eAAe,CAACsF,QAAQ,EAAE;EAC5B;EAIA,SAASgC,cAAcA,CAAA;IACrBjB,KAAK,CAACJ,CAAC,CAACR,aAAa,EAAE;IACvBY,KAAK,CAACD,CAAC,CAACX,aAAa,EAAE;IACvB6C,kBAAkB,EAAE;EACtB;EAEA,SAASA,kBAAkBA,CAAA;IACzBjC,KAAK,CAACJ,CAAC,CAACtB,iBAAiB,EAAE;IAC3B0B,KAAK,CAACD,CAAC,CAACzB,iBAAiB,EAAE;EAC7B;EAEA,SAAS4C,kBAAkBA,CAAA;IACzBlB,KAAK,CAACJ,CAAC,CAACrB,iBAAiB,EAAE;IAC3ByB,KAAK,CAACD,CAAC,CAACxB,iBAAiB,EAAE;EAC7B;EAEA7E,IAAI,CAAC4C,UAAU,CAAC4F,GAAG,CAAClC,KAAK,CAACJ,CAAC,CAAC7D,SAAS,CAAC;EACtCrC,IAAI,CAAC4C,UAAU,CAAC4F,GAAG,CAAClC,KAAK,CAACD,CAAC,CAAChE,SAAS,CAAC;EAGtC,IAAMoG,QAAQ,GAAG,SAAAA,CAACC,IAAiB;IAA0B,QAAC,CAAEA,IAAY,CAACC,KAAK;EAArB,CAAqB;EAElF,SAASX,0BAA0BA,CAACU,IAAwB,EAAEE,UAAmC;IAC/FA,UAAU,GAAGA,UAAU,IAAIC,QAAQ;IACnC,IAAI,CAACH,IAAI,IAAI,CAAED,QAAQ,CAACC,IAAI,CAAE,EAAE;MAC9B,OAAOE,UAAU;;IAGnB,IAAMrE,QAAQ,GAAGmE,IAAI,CAACC,KAAK,CAACpE,QAAQ;IACpC,IAAMuE,mBAAmB,GAAGvE,QAAQ,KAAK,UAAU;IACnD,IAAMwE,aAAa,GAAG,eAAe;IACrC,IAAIC,YAAY,GAAuBN,IAAI;IAE3C,OAAO,CAAC,CAACM,YAAY,IAAIA,YAAY,KAAKJ,UAAU,EAAE;MACpD,IAAI,EAAEE,mBAAmB,IAAIE,YAAY,CAACL,KAAK,CAACpE,QAAQ,KAAK,QAAQ,CAAC,EAAE;QACtE,IAAM0E,aAAa,GAAGC,gBAAgB,CAACF,YAAY,CAAC;QAEpD,IAAID,aAAa,CAACI,IAAI,CAAC,EAAE,GAAGF,aAAa,CAACG,QAAQ,GAAGH,aAAa,CAACI,SAAS,GAAGJ,aAAa,CAACK,SAAS,CAAC,EAAE;UACvG;;;MAIJN,YAAY,GAAGA,YAAY,CAACO,aAAa;;IAG3C,OAAOhF,QAAQ,KAAK,OAAO,IAAI,CAACyE,YAAY,IAAIA,YAAY,KAAKN,IAAI,GAAGA,IAAI,CAACc,aAAa,IAAIZ,UAAU,GAAGI,YAAY;EACzH;EAEA,OAAO1C,KAAK;AACd;AA7WAmD,OAAA,CAAA1J,MAAA,GAAAA,MAAA;AA+WA0J,OAAA,CAAAvJ,OAAA,GAAeH,MAAM","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}