{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractDimensionalSpaceConverter = void 0;\nvar util = require(\"../util\");\nvar AbstractDimensionalSpaceConverter = function () {\n  function AbstractDimensionalSpaceConverter(gridDimension) {\n    this.gridDimension = gridDimension;\n  }\n  AbstractDimensionalSpaceConverter.prototype.clamp = function (idx) {\n    return util.clamp(idx, 0, this.count() - 1);\n  };\n  AbstractDimensionalSpaceConverter.prototype.prev = function (coord) {\n    return this.iterateWhileHidden(-1, coord);\n  };\n  AbstractDimensionalSpaceConverter.prototype.next = function (coord) {\n    return this.iterateWhileHidden(1, coord);\n  };\n  AbstractDimensionalSpaceConverter.prototype.get = function (coord) {\n    return this.gridDimension.rowColModel.get(this.toVirtual(coord));\n  };\n  AbstractDimensionalSpaceConverter.prototype.indexes = function (opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    opts.from = opts.from || 0;\n    var count = this.count();\n    opts.to = opts.to && opts.to + 1 || opts.length && opts.length + opts.from || count;\n    var indexes = [];\n    for (var idx = Math.max(opts.from, 0); idx != undefined && idx < Math.min(opts.to, count); idx = opts.reverse ? this.prev(idx) : this.next(idx)) {\n      indexes.push(idx);\n    }\n    return indexes;\n  };\n  AbstractDimensionalSpaceConverter.prototype.iterate = function () {\n    var opts;\n    var fn;\n    if (arguments.length === 2) {\n      opts = arguments[0];\n      fn = arguments[1];\n    } else {\n      fn = arguments[0];\n    }\n    this.indexes(opts).some(function (idx) {\n      return !!fn(idx);\n    });\n  };\n  AbstractDimensionalSpaceConverter.prototype.iterateWhileHidden = function (step, start) {\n    if (step === void 0) {\n      step = 1;\n    }\n    for (var i = start + step; i < this.count() && i >= 0; i += step) {\n      if (!this.get(i).hidden) {\n        return i;\n      }\n    }\n    return undefined;\n  };\n  return AbstractDimensionalSpaceConverter;\n}();\nexports.AbstractDimensionalSpaceConverter = AbstractDimensionalSpaceConverter;","map":{"version":3,"names":["util","require","AbstractDimensionalSpaceConverter","gridDimension","prototype","clamp","idx","count","prev","coord","iterateWhileHidden","next","get","rowColModel","toVirtual","indexes","opts","from","to","length","Math","max","undefined","min","reverse","push","iterate","fn","arguments","some","step","start","i","hidden","exports"],"sources":["C:\\amazon\\amazon\\node_modules\\grid\\src\\modules\\space\\dimensional-converter.ts"],"sourcesContent":["import { IColDescriptor, IRowDescriptor } from '../abstract-row-col-model';\nimport { IGridDimension } from '../core';\nimport * as  util from '../util';\n\nexport type DimensionalSpaceCoordConverter = (spaceCoord: number) => number;\n\nexport interface IIndexOpts {\n  from?: number;\n  to?: number;\n  length?: number;\n  reverse?: boolean;\n}\n\nexport abstract class AbstractDimensionalSpaceConverter<T extends IColDescriptor | IRowDescriptor> {\n  gridDimension: IGridDimension;\n  constructor(gridDimension: IGridDimension) {\n    this.gridDimension = gridDimension;\n  }\n  abstract toVirtual(spaceCoord: number): number;\n  abstract toView(spaceCoord: number): number;\n  abstract toData(spaceCoord: number): number;\n  abstract count(): number;\n  clamp(idx: number): number {\n    return util.clamp(idx, 0, this.count() - 1);\n  }\n  prev(coord: number) {\n    return this.iterateWhileHidden(-1, coord);\n  }\n  next(coord: number) {\n    return this.iterateWhileHidden(1, coord);\n  }\n  get(coord: number): T {\n    return this.gridDimension.rowColModel.get(this.toVirtual(coord)) as T;\n  }\n\n  indexes(opts: IIndexOpts = {}) {\n    opts.from = opts.from || 0;\n    const count = this.count();\n    opts.to = (opts.to && opts.to + 1) ||\n      (opts.length && opts.length + opts.from) ||\n      count;\n    const indexes = [];\n    for (let idx: number | undefined = Math.max(opts.from, 0);\n      idx != undefined && idx < Math.min(opts.to, count);\n      idx = opts.reverse ? this.prev(idx) : this.next(idx)) {\n      indexes.push(idx);\n    }\n    return indexes;\n  }\n  iterate(opts: IIndexOpts, fn: (idx: number) => boolean | undefined): void;\n  iterate(fn: (idx: number) => boolean | undefined): void;\n  iterate() {\n    let opts: IIndexOpts | undefined;\n    let fn: (idx: number) => boolean | undefined;\n    if (arguments.length === 2) {\n      opts = arguments[0];\n      fn = arguments[1];\n    } else {\n      fn = arguments[0];\n    }\n    this.indexes(opts).some((idx: number) => {\n      return !!fn(idx);\n    });\n  }\n  private iterateWhileHidden(step: number = 1, start: number) {\n    for (let i = start + step; i < this.count() && i >= 0; i += step) {\n      if (!this.get(i).hidden) {\n        return i;\n      }\n    }\n    return undefined;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}